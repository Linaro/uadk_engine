// SPDX-License-Identifier: Apache-2.0
/*
 * Copyright 2015-2022 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */
#include <string.h>
#include <openssl/bn.h>
#include <openssl/dsaerr.h>
#include <openssl/err.h>
#include <openssl/rand.h>
#include <openssl/sha.h>
#include "uadk_prov_ffc.h"

#if BN_BITS2 == 64
#define BN_DEF(lo, hi) (BN_ULONG)hi << 32 | lo
#else
#define BN_DEF(lo, hi) lo, hi
#endif

/* DH parameters from RFC3526 */

# ifndef FIPS_MODULE
/*
 * "1536-bit MODP Group" from RFC3526, Section 2.
 *
 * The prime is: 2^1536 - 2^1472 - 1 + 2^64 * { [2^1406 pi] + 741804 }
 *
 * RFC3526 specifies a generator of 2.
 * RFC2412 specifies a generator of 22.
 */
static const BN_ULONG modp_1536_p[] = {
	BN_DEF(0xFFFFFFFF, 0xFFFFFFFF), BN_DEF(0xCA237327, 0xF1746C08),
	BN_DEF((0x4ABC9804), (0x670C354E)), BN_DEF((0x7096966D), (0x9ED52907)),
	BN_DEF(0x208552BB, 0x1C62F356), BN_DEF(0xDCA3AD96, 0x83655D23),
	BN_DEF(0xFD24CF5F, 0x69163FA8), BN_DEF(0x1C55D39A, 0x98DA4836),
	BN_DEF(0xA163BF05, 0xC2007CB8), BN_DEF(0xECE45B3D, 0x49286651),
	BN_DEF(0x7C4B1FE6, 0xAE9F2411), BN_DEF(0x5A899FA5, 0xEE386BFB),
	BN_DEF(0xF406B7ED, 0x0BFF5CB6), BN_DEF(0xA637ED6B, 0xF44C42E9),
	BN_DEF(0x625E7EC6, 0xE485B576), BN_DEF(0x6D51C245, 0x4FE1356D),
	BN_DEF(0xF25F1437, 0x302B0A6D), BN_DEF(0xCD3A431B, 0xEF9519B3),
	BN_DEF(0x8E3404DD, 0x514A0879), BN_DEF(0x3B139B22, 0x020BBEA6),
	BN_DEF(0x8A67CC74, 0x29024E08), BN_DEF(0x80DC1CD1, 0xC4C6628B),
	BN_DEF(0x2168C234, 0xC90FDAA2), BN_DEF(0xFFFFFFFF, 0xFFFFFFFF)
};

/* q = (p - 1) / 2 */
static const BN_ULONG modp_1536_q[] = {
	BN_DEF(0xFFFFFFFF, 0xFFFFFFFF), BN_DEF(0x6511B993, 0x78BA3604),
	BN_DEF(0x255E4C02, 0xB3861AA7), BN_DEF(0xB84B4B36, 0xCF6A9483),
	BN_DEF(0x1042A95D, 0x0E3179AB), BN_DEF(0xEE51D6CB, 0xC1B2AE91),
	BN_DEF(0x7E9267AF, 0x348B1FD4), BN_DEF(0x0E2AE9CD, 0xCC6D241B),
	BN_DEF(0x50B1DF82, 0xE1003E5C), BN_DEF(0xF6722D9E, 0x24943328),
	BN_DEF(0xBE258FF3, 0xD74F9208), BN_DEF(0xAD44CFD2, 0xF71C35FD),
	BN_DEF(0x7A035BF6, 0x85FFAE5B), BN_DEF(0xD31BF6B5, 0x7A262174),
	BN_DEF(0x312F3F63, 0xF242DABB), BN_DEF(0xB6A8E122, 0xA7F09AB6),
	BN_DEF(0xF92F8A1B, 0x98158536), BN_DEF(0xE69D218D, 0xF7CA8CD9),
	BN_DEF(0xC71A026E, 0x28A5043C), BN_DEF(0x1D89CD91, 0x0105DF53),
	BN_DEF(0x4533E63A, 0x94812704), BN_DEF(0xC06E0E68, 0x62633145),
	BN_DEF(0x10B4611A, 0xE487ED51), BN_DEF(0xFFFFFFFF, 0x7FFFFFFF)
};
# endif /* FIPS_MODULE */

/*
 * "2048-bit MODP Group" from RFC3526, Section 3.
 *
 * The prime is: 2^2048 - 2^1984 - 1 + 2^64 * { [2^1918 pi] + 124476 }
 *
 * RFC3526 specifies a generator of 2.
 */
static const BN_ULONG modp_2048_p[] = {
	BN_DEF(0xFFFFFFFF, 0xFFFFFFFF), BN_DEF(0x8AACAA68, 0x15728E5A),
	BN_DEF(0x98FA0510, 0x15D22618), BN_DEF(0xEA956AE5, 0x3995497C),
	BN_DEF(0x95581718, 0xDE2BCBF6), BN_DEF(0x6F4C52C9, 0xB5C55DF0),
	BN_DEF(0xEC07A28F, 0x9B2783A2), BN_DEF(0x180E8603, 0xE39E772C),
	BN_DEF(0x2E36CE3B, 0x32905E46), BN_DEF(0xCA18217C, 0xF1746C08),
	BN_DEF(0x4ABC9804, 0x670C354E), BN_DEF(0x7096966D, 0x9ED52907),
	BN_DEF(0x208552BB, 0x1C62F356), BN_DEF(0xDCA3AD96, 0x83655D23),
	BN_DEF(0xFD24CF5F, 0x69163FA8), BN_DEF(0x1C55D39A, 0x98DA4836),
	BN_DEF((0xA163BF05), (0xC2007CB8)), BN_DEF(0xECE45B3D, 0x49286651),
	BN_DEF(0x7C4B1FE6, 0xAE9F2411), BN_DEF(0x5A899FA5, 0xEE386BFB),
	BN_DEF(0xF406B7ED, 0x0BFF5CB6), BN_DEF(0xA637ED6B, 0xF44C42E9),
	BN_DEF((0x625E7EC6), (0xE485B576)), BN_DEF(0x6D51C245, 0x4FE1356D),
	BN_DEF(0xF25F1437, 0x302B0A6D), BN_DEF(0xCD3A431B, 0xEF9519B3),
	BN_DEF((0x8E3404DD), (0x514A0879)), BN_DEF(0x3B139B22, 0x020BBEA6),
	BN_DEF(0x8A67CC74, 0x29024E08), BN_DEF(0x80DC1CD1, 0xC4C6628B),
	BN_DEF(0x2168C234, 0xC90FDAA2), BN_DEF(0xFFFFFFFF, 0xFFFFFFFF)
};
/* q = (p - 1) / 2 */
static const BN_ULONG modp_2048_q[] = {
	BN_DEF(0xFFFFFFFF,  0x7FFFFFFF), BN_DEF(0x45565534,  0x0AB9472D),
	BN_DEF((0x4C7D0288),  0x8AE9130C), BN_DEF(0x754AB572,  0x1CCAA4BE),
	BN_DEF(0x4AAC0B8C,  0xEF15E5FB), BN_DEF(0x37A62964,  0xDAE2AEF8),
	BN_DEF(0x7603D147,  0xCD93C1D1), BN_DEF(0x0C074301,  0xF1CF3B96),
	BN_DEF(0x171B671D,  0x19482F23), BN_DEF(0x650C10BE,  0x78BA3604),
	BN_DEF((0x255E4C02),  0xB3861AA7), BN_DEF(0xB84B4B36,  0xCF6A9483),
	BN_DEF(0x1042A95D,  0x0E3179AB), BN_DEF(0xEE51D6CB,  0xC1B2AE91),
	BN_DEF(0x7E9267AF,  0x348B1FD4), BN_DEF(0x0E2AE9CD,  0xCC6D241B),
	BN_DEF(0x50B1DF82,  0xE1003E5C), BN_DEF(0xF6722D9E,  0x24943328),
	BN_DEF(0xBE258FF3,  0xD74F9208), BN_DEF(0xAD44CFD2,  0xF71C35FD),
	BN_DEF((0x7A035BF6),  0x85FFAE5B), BN_DEF(0xD31BF6B5,  0x7A262174),
	BN_DEF(0x312F3F63,  0xF242DABB), BN_DEF(0xB6A8E122,  0xA7F09AB6),
	BN_DEF(0xF92F8A1B,  0x98158536), BN_DEF(0xE69D218D,  0xF7CA8CD9),
	BN_DEF(0xC71A026E,  0x28A5043C), BN_DEF(0x1D89CD91,  0x0105DF53),
	BN_DEF((0x4533E63A),  0x94812704), BN_DEF(0xC06E0E68,  0x62633145),
	BN_DEF(0x10B4611A,  0xE487ED51), BN_DEF(0xFFFFFFFF,  0x7FFFFFFF),
};

/*-
 * "3072-bit MODP Group" from RFC3526, Section 4.
 *
 * The prime is: 2^3072 - 2^3008 - 1 + 2^64 * { [2^2942 pi] + 1690314 }
 *
 * RFC3526 specifies a generator of 2.
 */
static const BN_ULONG modp_3072_p[] = {
	BN_DEF(0xFFFFFFFF, 0xFFFFFFFF), BN_DEF(0xA93AD2CA, 0x4B82D120),
	BN_DEF(0xE0FD108E, 0x43DB5BFC), BN_DEF(0x74E5AB31, 0x08E24FA0),
	BN_DEF(0xBAD946E2, 0x770988C0), BN_DEF(0x7A615D6C, 0xBBE11757),
	BN_DEF(0x177B200C, 0x521F2B18), BN_DEF(0x3EC86A64, 0xD8760273),
	BN_DEF(0xD98A0864, 0xF12FFA06), BN_DEF(0x1AD2EE6B, 0xCEE3D226),
	BN_DEF(0x4A25619D, 0x1E8C94E0), BN_DEF(0xDB0933D7, 0xABF5AE8C),
	BN_DEF(0xA6E1E4C7, 0xB3970F85), BN_DEF(0x5D060C7D, 0x8AEA7157),
	BN_DEF(0x58DBEF0A, 0xECFB8504), BN_DEF(0xDF1CBA64, 0xA85521AB),
	BN_DEF(0x04507A33, 0xAD33170D), BN_DEF(0x8AAAC42D, 0x15728E5A),
	BN_DEF(0x98FA0510, 0x15D22618), BN_DEF(0xEA956AE5, 0x3995497C),
	BN_DEF(0x95581718, 0xDE2BCBF6), BN_DEF(0x6F4C52C9, 0xB5C55DF0),
	BN_DEF(0xEC07A28F, 0x9B2783A2), BN_DEF(0x180E8603, 0xE39E772C),
	BN_DEF(0x2E36CE3B, 0x32905E46), BN_DEF(0xCA18217C, 0xF1746C08),
	BN_DEF(0x4ABC9804, 0x670C354E), BN_DEF(0x7096966D, 0x9ED52907),
	BN_DEF(0x208552BB, 0x1C62F356), BN_DEF(0xDCA3AD96, 0x83655D23),
	BN_DEF((0xFD24CF5F), (0x69163FA8)), BN_DEF(0x1C55D39A, 0x98DA4836),
	BN_DEF(0xA163BF05, 0xC2007CB8), BN_DEF(0xECE45B3D, 0x49286651),
	BN_DEF((0x7C4B1FE6), (0xAE9F2411)), BN_DEF(0x5A899FA5, 0xEE386BFB),
	BN_DEF(0xF406B7ED, 0x0BFF5CB6), BN_DEF(0xA637ED6B, 0xF44C42E9),
	BN_DEF(0x625E7EC6, 0xE485B576), BN_DEF(0x6D51C245, 0x4FE1356D),
	BN_DEF(0xF25F1437, 0x302B0A6D), BN_DEF(0xCD3A431B, 0xEF9519B3),
	BN_DEF(0x8E3404DD, 0x514A0879), BN_DEF(0x3B139B22, 0x020BBEA6),
	BN_DEF((0x8A67CC74), (0x29024E08)), BN_DEF(0x80DC1CD1, 0xC4C6628B),
	BN_DEF(0x2168C234, 0xC90FDAA2), BN_DEF(0xFFFFFFFF, 0xFFFFFFFF)
};
/* q = (p - 1) / 2 */
static const BN_ULONG modp_3072_q[] = {
	BN_DEF(0xFFFFFFFF,  0x7FFFFFFF), BN_DEF(0x549D6965,  0x25C16890),
	BN_DEF(0x707E8847,  0xA1EDADFE), BN_DEF(0x3A72D598,  0x047127D0),
	BN_DEF(0x5D6CA371,  0x3B84C460), BN_DEF(0xBD30AEB6,  0x5DF08BAB),
	BN_DEF(0x0BBD9006,  0x290F958C), BN_DEF(0x9F643532,  0x6C3B0139),
	BN_DEF(0x6CC50432,  0xF897FD03), BN_DEF(0x0D697735,  0xE771E913),
	BN_DEF(0x2512B0CE,  0x8F464A70), BN_DEF(0x6D8499EB,  0xD5FAD746),
	BN_DEF(0xD370F263,  0xD9CB87C2), BN_DEF(0xAE83063E,  0x457538AB),
	BN_DEF(0x2C6DF785,  0x767DC282), BN_DEF(0xEF8E5D32,  0xD42A90D5),
	BN_DEF(0x82283D19,  0xD6998B86), BN_DEF(0x45556216,  0x0AB9472D),
	BN_DEF(0x4C7D0288,  0x8AE9130C), BN_DEF(0x754AB572,  0x1CCAA4BE),
	BN_DEF(0x4AAC0B8C,  (0xEF15E5FB)), BN_DEF(0x37A62964,  0xDAE2AEF8),
	BN_DEF(0x7603D147,  0xCD93C1D1), BN_DEF(0x0C074301,  0xF1CF3B96),
	BN_DEF(0x171B671D,  0x19482F23), BN_DEF(0x650C10BE,  0x78BA3604),
	BN_DEF(0x255E4C02,  (0xB3861AA7)), BN_DEF(0xB84B4B36,  0xCF6A9483),
	BN_DEF(0x1042A95D,  0x0E3179AB), BN_DEF(0xEE51D6CB,  0xC1B2AE91),
	BN_DEF(0x7E9267AF,  0x348B1FD4), BN_DEF(0x0E2AE9CD,  0xCC6D241B),
	BN_DEF(0x50B1DF82,  0xE1003E5C), BN_DEF(0xF6722D9E,  0x24943328),
	BN_DEF(0xBE258FF3,  0xD74F9208), BN_DEF(0xAD44CFD2,  0xF71C35FD),
	BN_DEF(0x7A035BF6,  (0x85FFAE5B)), BN_DEF(0xD31BF6B5,  0x7A262174),
	BN_DEF(0x312F3F63,  0xF242DABB), BN_DEF(0xB6A8E122,  0xA7F09AB6),
	BN_DEF(0xF92F8A1B,  0x98158536), BN_DEF(0xE69D218D,  0xF7CA8CD9),
	BN_DEF(0xC71A026E,  (0x28A5043C)), BN_DEF(0x1D89CD91,  0x0105DF53),
	BN_DEF(0x4533E63A,  0x94812704), BN_DEF(0xC06E0E68,  0x62633145),
	BN_DEF(0x10B4611A,  0xE487ED51), BN_DEF(0xFFFFFFFF,  0x7FFFFFFF),
};

/*-
 * "4096-bit MODP Group" from RFC3526, Section 5.
 *
 * The prime is: 2^4096 - 2^4032 - 1 + 2^64 * { [2^3966 pi] + 240904 }
 *
 * RFC3526 specifies a generator of 2.
 */
static const BN_ULONG modp_4096_p[] = {
	BN_DEF(0xFFFFFFFF, 0xFFFFFFFF), BN_DEF(0x34063199, 0x4DF435C9),
	BN_DEF(0x90A6C08F, 0x86FFB7DC), BN_DEF(0x8D8FDDC1, 0x93B4EA98),
	BN_DEF(0xD5B05AA9, 0xD0069127), BN_DEF(0x2170481C, 0xB81BDD76),
	BN_DEF(0xCEE2D7AF, 0x1F612970), BN_DEF(0x515BE7ED, 0x233BA186),
	BN_DEF(0xA090C3A2, 0x99B2964F), BN_DEF(0x4E6BC05D, 0x287C5947),
	BN_DEF(0x1FBECAA6, 0x2E8EFC14), BN_DEF(0x04DE8EF9, 0xDBBBC2DB),
	BN_DEF(0x2AD44CE8, 0x2583E9CA), BN_DEF(0xB6150BDA, 0x1A946834),
	BN_DEF(0x6AF4E23C, 0x99C32718), BN_DEF(0xBDBA5B26, 0x88719A10),
	BN_DEF(0xA787E6D7, 0x1A723C12), BN_DEF(0xA9210801, 0x4B82D120),
	BN_DEF(0xE0FD108E, 0x43DB5BFC), BN_DEF(0x74E5AB31, 0x08E24FA0),
	BN_DEF(0xBAD946E2, 0x770988C0), BN_DEF(0x7A615D6C, 0xBBE11757),
	BN_DEF(0x177B200C, 0x521F2B18), BN_DEF(0x3EC86A64, 0xD8760273),
	BN_DEF(0xD98A0864, 0xF12FFA06), BN_DEF(0x1AD2EE6B, 0xCEE3D226),
	BN_DEF(0x4A25619D, 0x1E8C94E0), BN_DEF(0xDB0933D7, 0xABF5AE8C),
	BN_DEF(0xA6E1E4C7, 0xB3970F85), BN_DEF(0x5D060C7D, 0x8AEA7157),
	BN_DEF(0x58DBEF0A, 0xECFB8504), BN_DEF(0xDF1CBA64, 0xA85521AB),
	BN_DEF(0x04507A33, 0xAD33170D), BN_DEF(0x8AAAC42D, 0x15728E5A),
	BN_DEF(0x98FA0510, 0x15D22618), BN_DEF(0xEA956AE5, 0x3995497C),
	BN_DEF(0x95581718, 0xDE2BCBF6), BN_DEF(0x6F4C52C9, 0xB5C55DF0),
	BN_DEF(0xEC07A28F, 0x9B2783A2), BN_DEF(0x180E8603, 0xE39E772C),
	BN_DEF(0x2E36CE3B, 0x32905E46), BN_DEF(0xCA18217C, 0xF1746C08),
	BN_DEF(0x4ABC9804, 0x670C354E), BN_DEF(0x7096966D, 0x9ED52907),
	BN_DEF(0x208552BB, 0x1C62F356), BN_DEF(0xDCA3AD96, 0x83655D23),
	BN_DEF((0xFD24CF5F), 0x69163FA8), BN_DEF(0x1C55D39A, 0x98DA4836),
	BN_DEF(0xA163BF05, 0xC2007CB8), BN_DEF(0xECE45B3D, 0x49286651),
	BN_DEF(0x7C4B1FE6, (0xAE9F2411)), BN_DEF(0x5A899FA5, 0xEE386BFB),
	BN_DEF(0xF406B7ED, 0x0BFF5CB6), BN_DEF(0xA637ED6B, 0xF44C42E9),
	BN_DEF((0x625E7EC6), 0xE485B576), BN_DEF(0x6D51C245, 0x4FE1356D),
	BN_DEF(0xF25F1437, 0x302B0A6D), BN_DEF(0xCD3A431B, 0xEF9519B3),
	BN_DEF(0x8E3404DD, 0x514A0879), BN_DEF(0x3B139B22, 0x020BBEA6),
	BN_DEF(0x8A67CC74, (0x29024E08)), BN_DEF(0x80DC1CD1, 0xC4C6628B),
	BN_DEF(0x2168C234, 0xC90FDAA2), BN_DEF(0xFFFFFFFF, 0xFFFFFFFF)
};
/* q = (p - 1) / 2 */
static const BN_ULONG modp_4096_q[] = {
	BN_DEF(0xFFFFFFFF,  0xFFFFFFFF), BN_DEF(0x9A0318CC,  0xA6FA1AE4),
	BN_DEF(0x48536047,  0xC37FDBEE), BN_DEF(0x46C7EEE0,  0xC9DA754C),
	BN_DEF(0xEAD82D54,  0x68034893), BN_DEF(0x10B8240E,  0xDC0DEEBB),
	BN_DEF(0x67716BD7,  0x8FB094B8), BN_DEF(0x28ADF3F6,  0x119DD0C3),
	BN_DEF(0xD04861D1,  0xCCD94B27), BN_DEF(0xA735E02E,  0x143E2CA3),
	BN_DEF(0x0FDF6553,  0x97477E0A), BN_DEF(0x826F477C,  0x6DDDE16D),
	BN_DEF(0x156A2674,  0x12C1F4E5), BN_DEF(0x5B0A85ED,  0x0D4A341A),
	BN_DEF(0x357A711E,  0x4CE1938C), BN_DEF(0x5EDD2D93,  0xC438CD08),
	BN_DEF(0x53C3F36B,  0x8D391E09), BN_DEF(0x54908400,  0x25C16890),
	BN_DEF(0x707E8847,  0xA1EDADFE), BN_DEF(0x3A72D598,  0x047127D0),
	BN_DEF(0x5D6CA371,  0x3B84C460), BN_DEF(0xBD30AEB6,  0x5DF08BAB),
	BN_DEF(0x0BBD9006,  0x290F958C), BN_DEF(0x9F643532,  0x6C3B0139),
	BN_DEF(0x6CC50432,  0xF897FD03), BN_DEF(0x0D697735,  0xE771E913),
	BN_DEF(0x2512B0CE,  0x8F464A70), BN_DEF(0x6D8499EB,  0xD5FAD746),
	BN_DEF(0xD370F263,  0xD9CB87C2), BN_DEF(0xAE83063E,  0x457538AB),
	BN_DEF(0x2C6DF785,  0x767DC282), BN_DEF(0xEF8E5D32,  0xD42A90D5),
	BN_DEF(0x82283D19,  0xD6998B86), BN_DEF(0x45556216,  0x0AB9472D),
	BN_DEF(0x4C7D0288,  0x8AE9130C), BN_DEF(0x754AB572,  0x1CCAA4BE),
	BN_DEF(0x4AAC0B8C,  0xEF15E5FB), BN_DEF(0x37A62964,  0xDAE2AEF8),
	BN_DEF(0x7603D147,  0xCD93C1D1), BN_DEF(0x0C074301,  0xF1CF3B96),
	BN_DEF(0x171B671D,  0x19482F23), BN_DEF(0x650C10BE,  (0x78BA3604)),
	BN_DEF(0x255E4C02,  0xB3861AA7), BN_DEF(0xB84B4B36,  0xCF6A9483),
	BN_DEF(0x1042A95D,  0x0E3179AB), BN_DEF(0xEE51D6CB,  0xC1B2AE91),
	BN_DEF(0x7E9267AF,  0x348B1FD4), BN_DEF(0x0E2AE9CD,  0xCC6D241B),
	BN_DEF(0x50B1DF82,  0xE1003E5C), BN_DEF(0xF6722D9E,  (0x24943328)),
	BN_DEF(0xBE258FF3,  0xD74F9208), BN_DEF(0xAD44CFD2,  0xF71C35FD),
	BN_DEF(0x7A035BF6,  0x85FFAE5B), BN_DEF(0xD31BF6B5,  0x7A262174),
	BN_DEF(0x312F3F63,  0xF242DABB), BN_DEF(0xB6A8E122,  0xA7F09AB6),
	BN_DEF(0xF92F8A1B,  0x98158536), BN_DEF(0xE69D218D,  (0xF7CA8CD9)),
	BN_DEF(0xC71A026E,  0x28A5043C), BN_DEF(0x1D89CD91,  0x0105DF53),
	BN_DEF(0x4533E63A,  0x94812704), BN_DEF(0xC06E0E68,  0x62633145),
	BN_DEF(0x10B4611A,  0xE487ED51), BN_DEF(0xFFFFFFFF,  0x7FFFFFFF),
};

/* DH parameters from RFC5114 */
static const BN_ULONG dh1024_160_p[] = {
	BN_DEF(0x2E4A4371, 0xDF1FB2BC), BN_DEF(0x6D4DA708, 0xE68CFDA7),
	BN_DEF(0x365C1A65, 0x45BF37DF), BN_DEF(0x0DC8B4BD, 0xA151AF5F),
	BN_DEF(0xF55BCCC0, 0xFAA31A4F), BN_DEF(0xE5644738, 0x4EFFD6FA),
	BN_DEF(0x219A7372, 0x98488E9C), BN_DEF(0x90C4BD70, 0xACCBDD7D),
	BN_DEF(0xD49B83BF, 0x24975C3C), BN_DEF(0xA9061123, 0x13ECB4AE),
	BN_DEF(0x2EE652C0, 0x9838EF1E), BN_DEF(0x75A23D18, 0x6073E286),
	BN_DEF(0x52D23B61, 0x9A6A9DCA), BN_DEF(0xFB06A3C6, 0x52C99FBC),
	BN_DEF(0xAE5D54EC, 0xDE92DE5E), BN_DEF(0xA080E01D, 0xB10B8F96)
};
static const BN_ULONG dh1024_160_q[] = {
	BN_DEF(0x49462353, 0x64B7CB9D), BN_DEF(0x8ABA4E7D, 0x81A8DF27),
	(BN_ULONG)0xF518AA87
};
static const BN_ULONG dh1024_160_g[] = {
	BN_DEF(0x22B3B2E5, 0x855E6EEB), BN_DEF(0xF97C2A24, 0x858F4DCE),
	BN_DEF(0x18D08BC8, 0x2D779D59), BN_DEF(0x8E73AFA3, 0xD662A4D1),
	BN_DEF(0x69B6A28A, 0x1DBF0A01), BN_DEF(0x7A091F53, 0xA6A24C08),
	BN_DEF(0x63F80A76, 0x909D0D22), BN_DEF(0xB9A92EE1, 0xD7FBD7D3),
	BN_DEF(0x9E2749F4, 0x5E91547F), BN_DEF(0xB01B886A, 0x160217B4),
	BN_DEF(0x5504F213, 0x777E690F), BN_DEF(0x5C41564B, 0x266FEA1E),
	BN_DEF(0x14266D31, 0xD6406CFF), BN_DEF(0x58AC507F, 0xF8104DD2),
	BN_DEF(0xEFB99905, 0x6765A442), BN_DEF(0xC3FD3412, 0xA4D1CBD5)
};

static const BN_ULONG dh2048_224_p[] = {
	BN_DEF(0x0C10E64F, 0x0AC4DFFE), BN_DEF(0x4E71B81C, 0xCF9DE538),
	BN_DEF(0xFFA31F71, 0x7EF363E2), BN_DEF(0x6B8E75B9, 0xE3FB73C1),
	BN_DEF(0x4BA80A29, 0xC9B53DCF), BN_DEF(0x16E79763, 0x23F10B0E),
	BN_DEF(0x13042E9B, 0xC52172E4), BN_DEF(0xC928B2B9, 0xBE60E69C),
	BN_DEF(0xB9E587E8, 0x80CD86A1), BN_DEF(0x98C641A4, 0x315D75E1),
	BN_DEF(0x44328387, 0xCDF93ACC), BN_DEF(0xDC0A486D, 0x15987D9A),
	BN_DEF(0x1FD5A074, 0x7310F712), BN_DEF(0xDE31EFDC, 0x278273C7),
	BN_DEF(0x415D9330, 0x1602E714), BN_DEF(0xBC8985DB, 0x81286130),
	BN_DEF(0x70918836, 0xB3BF8A31), BN_DEF(0xB9C49708, 0x6A00E0A0),
	BN_DEF(0x8BBC27BE, 0xC6BA0B2C), BN_DEF(0xED34DBF6, 0xC9F98D11),
	BN_DEF(0xB6C12207, 0x7AD5B7D0), BN_DEF(0x55B7394B, 0xD91E8FEF),
	BN_DEF(0xEFDA4DF8, 0x9037C9ED), BN_DEF(0xAD6AC212, 0x6D3F8152),
	BN_DEF(0x1274A0A6, 0x1DE6B85A), BN_DEF(0x309C180E, 0xEB3D688A),
	BN_DEF(0x7BA1DF15, 0xAF9A3C40), BN_DEF(0xF95A56DB, 0xE6FA141D),
	BN_DEF(0xB61D0A75, 0xB54B1597), BN_DEF(0x683B9FD1, 0xA20D64E5),
	BN_DEF(0x9559C51F, 0xD660FAA7), BN_DEF(0x9123A9D0, 0xAD107E1E)
};
static const BN_ULONG dh2048_224_q[] = {
	BN_DEF(0xB36371EB, 0xBF389A99), BN_DEF(0x4738CEBC, 0x1F80535A),
	BN_DEF(0x99717710, 0xC58D93FE), (BN_ULONG)0x801C0D34
};
static const BN_ULONG dh2048_224_g[] = {
	BN_DEF(0x191F2BFA, 0x84B890D3), BN_DEF(0x2A7065B3, 0x81BC087F),
	BN_DEF(0xF6EC0179, 0x19C418E1), BN_DEF(0x71CFFF4C, 0x7B5A0F1C),
	BN_DEF(0x9B6AA4BD, 0xEDFE72FE), BN_DEF(0x94B30269, 0x81E1BCFE),
	BN_DEF(0x8D6C0191, 0x566AFBB4), BN_DEF(0x409D13CD, 0xB539CCE3),
	BN_DEF(0x5F2FF381, 0x6AA21E7F), BN_DEF(0x770589EF, 0xD9E263E4),
	BN_DEF(0xD19963DD, 0x10E183ED), BN_DEF(0x150B8EEB, 0xB70A8137),
	BN_DEF(0x28C8F8AC, 0x051AE3D4), BN_DEF(0x0C1AB15B, 0xBB77A86F),
	BN_DEF(0x16A330EF, 0x6E3025E3), BN_DEF(0xD6F83456, 0x19529A45),
	BN_DEF(0x118E98D1, 0xF180EB34), BN_DEF(0x50717CBE, 0xB5F6C6B2),
	BN_DEF(0xDA7460CD, 0x09939D54), BN_DEF(0x22EA1ED4, 0xE2471504),
	BN_DEF(0x521BC98A, 0xB8A762D0), BN_DEF(0x5AC1348B, 0xF4D02727),
	BN_DEF(0x1999024A, 0xC1766910), BN_DEF(0xA8D66AD7, 0xBE5E9001),
	BN_DEF(0x620A8652, 0xC57DB17C), BN_DEF(0x00C29F52, 0xAB739D77),
	BN_DEF(0xA70C4AFA, 0xDD921F01), BN_DEF(0x10B9A6F0, 0xA6824A4E),
	BN_DEF(0xCFE4FFE3, 0x74866A08), BN_DEF(0x89998CAF, 0x6CDEBE7B),
	BN_DEF(0x8FFDAC50, 0x9DF30B5C), BN_DEF(0x4F2D9AE3, 0xAC4032EF)
};

static const BN_ULONG dh2048_256_p[] = {
	BN_DEF(0x1E1A1597, 0xDB094AE9), BN_DEF(0xD7EF09CA, 0x693877FA),
	BN_DEF(0x6E11715F, 0x6116D227), BN_DEF(0xC198AF12, 0xA4B54330),
	BN_DEF(0xD7014103, 0x75F26375), BN_DEF(0x54E710C3, 0xC3A3960A),
	BN_DEF(0xBD0BE621, 0xDED4010A), BN_DEF(0x89962856, 0xC0B857F6),
	BN_DEF(0x71506026, 0xB3CA3F79), BN_DEF(0xE6B486F6, 0x1CCACB83),
	BN_DEF(0x14056425, 0x67E144E5), BN_DEF(0xA41825D9, 0xF6A167B5),
	BN_DEF(0x96524D8E, 0x3AD83477), BN_DEF(0x51BFA4AB, 0xF13C6D9A),
	BN_DEF(0x35488A0E, 0x2D525267), BN_DEF(0xCAA6B790, 0xB63ACAE1),
	BN_DEF(0x81B23F76, 0x4FDB70C5), BN_DEF(0x12307F5C, 0xBC39A0BF),
	BN_DEF(0xB1E59BB8, 0xB941F54E), BN_DEF(0xD45F9088, 0x6C5BFC11),
	BN_DEF(0x4275BF7B, 0x22E0B1EF), BN_DEF(0x5B4758C0, 0x91F9E672),
	BN_DEF(0x6BCF67ED, 0x5A8A9D30), BN_DEF(0x97517ABD, 0x209E0C64),
	BN_DEF(0x830E9A7C, 0x3BF4296D), BN_DEF(0x34096FAA, 0x16C3D911),
	BN_DEF(0x61B2AA30, 0xFAF7DF45), BN_DEF(0xD61957D4, 0xE00DF8F1),
	BN_DEF(0x435E3B00, 0x5D2CEED4), BN_DEF(0x660DD0F2, 0x8CEEF608),
	BN_DEF(0x65195999, 0xFFBBD19C), BN_DEF(0xB4B6663C, 0x87A8E61D)
};
static const BN_ULONG dh2048_256_q[] = {
	BN_DEF(0x64F5FBD3, 0xA308B0FE), BN_DEF(0x1EB3750B, 0x99B1A47D),
	BN_DEF(0x40129DA2, 0xB4479976), BN_DEF(0xA709A097, 0x8CF83642)
};
static const BN_ULONG dh2048_256_g[] = {
	BN_DEF(0x6CC41659, 0x664B4C0F), BN_DEF(0xEF98C582, 0x5E2327CF),
	BN_DEF(0xD4795451, 0xD647D148), BN_DEF(0x90F00EF8, 0x2F630784),
	BN_DEF(0x1DB246C3, 0x184B523D), BN_DEF(0xCDC67EB6, 0xC7891428),
	BN_DEF(0x0DF92B52, 0x7FD02837), BN_DEF(0x64E0EC37, 0xB3353BBB),
	BN_DEF(0x57CD0915, 0xECD06E15), BN_DEF(0xDF016199, 0xB7D2BBD2),
	BN_DEF(0x052588B9, 0xC8484B1E), BN_DEF(0x13D3FE14, 0xDB2A3B73),
	BN_DEF(0xD182EA0A, 0xD052B985), BN_DEF(0xE83B9C80, 0xA4BD1BFF),
	BN_DEF(0xFB3F2E55, 0xDFC967C1), BN_DEF(0x767164E1, 0xB5045AF2),
	BN_DEF(0x6F2F9193, 0x1D14348F), BN_DEF(0x428EBC83, 0x64E67982),
	BN_DEF(0x82D6ED38, 0x8AC376D2), BN_DEF(0xAAB8A862, 0x777DE62A),
	BN_DEF(0xE9EC144B, 0xDDF463E5), BN_DEF(0xC77A57F2, 0x0196F931),
	BN_DEF(0x41000A65, 0xA55AE313), BN_DEF(0xC28CBB18, 0x901228F8),
	BN_DEF(0x7E8C6F62, 0xBC3773BF), BN_DEF(0x0C6B47B1, 0xBE3A6C1B),
	BN_DEF(0xAC0BB555, 0xFF4FED4A), BN_DEF(0x77BE463F, 0x10DBC150),
	BN_DEF(0x1A0BA125, 0x07F4793A), BN_DEF(0x21EF2054, 0x4CA7B18F),
	BN_DEF(0x60EDBD48, 0x2E775066), BN_DEF(0x73134D0B, 0x3FB32C9B)
};

/* Primes from RFC 7919 */
static const BN_ULONG ffdhe2048_p[] = {
	BN_DEF(0xFFFFFFFF, 0xFFFFFFFF), BN_DEF(0x61285C97, 0x886B4238),
	BN_DEF(0xC1B2EFFA, 0xC6F34A26), BN_DEF(0x7D1683B2, 0xC58EF183),
	BN_DEF(0x2EC22005, 0x3BB5FCBC), BN_DEF(0x4C6FAD73, 0xC3FE3B1B),
	BN_DEF(0xEEF28183, 0x8E4F1232), BN_DEF(0xE98583FF, 0x9172FE9C),
	BN_DEF(0x28342F61, 0xC03404CD), BN_DEF(0xCDF7E2EC, 0x9E02FCE1),
	BN_DEF(0xEE0A6D70, 0x0B07A7C8), BN_DEF(0x6372BB19, 0xAE56EDE7),
	BN_DEF(0xDE394DF4, 0x1D4F42A3), BN_DEF(0x60D7F468, 0xB96ADAB7),
	BN_DEF(0xB2C8E3FB, 0xD108A94B), BN_DEF(0xB324FB61, 0xBC0AB182),
	BN_DEF(0x483A797A, 0x30ACCA4F), BN_DEF(0x36ADE735, 0x1DF158A1),
	BN_DEF(0xF3EFE872, 0xE2A689DA), BN_DEF(0xE0E68B77, 0x984F0C70),
	BN_DEF(0x7F57C935, 0xB557135E), BN_DEF(0x3DED1AF3, 0x85636555),
	BN_DEF(0x5F066ED0, 0x2433F51F), BN_DEF(0xD5FD6561, 0xD3DF1ED5),
	BN_DEF(0xAEC4617A, 0xF681B202), BN_DEF(0x630C75D8, 0x7D2FE363),
	BN_DEF(0x249B3EF9, 0xCC939DCE), BN_DEF(0x146433FB, 0xA9E13641),
	BN_DEF(0xCE2D3695, 0xD8B9C583), BN_DEF(0x273D3CF1, 0xAFDC5620),
	BN_DEF(0xA2BB4A9A, 0xADF85458), BN_DEF(0xFFFFFFFF, 0xFFFFFFFF)
};
/* q = (p - 1) / 2 */
static const BN_ULONG ffdhe2048_q[] = {
	BN_DEF(0xFFFFFFFF,  0xFFFFFFFF), BN_DEF(0x30942E4B,  0x4435A11C),
	BN_DEF(0x60D977FD,  0x6379A513), BN_DEF(0xBE8B41D9,  0xE2C778C1),
	BN_DEF(0x17611002,  0x9DDAFE5E), BN_DEF(0xA637D6B9,  0xE1FF1D8D),
	BN_DEF(0x777940C1,  0xC7278919), BN_DEF(0x74C2C1FF,  0xC8B97F4E),
	BN_DEF(0x941A17B0,  0x601A0266), BN_DEF(0xE6FBF176,  0x4F017E70),
	BN_DEF(0x770536B8,  0x8583D3E4), BN_DEF(0xB1B95D8C,  0x572B76F3),
	BN_DEF(0xEF1CA6FA,  0x0EA7A151), BN_DEF(0xB06BFA34,  0xDCB56D5B),
	BN_DEF(0xD96471FD,  0xE88454A5), BN_DEF(0x59927DB0,  0x5E0558C1),
	BN_DEF(0xA41D3CBD,  0x98566527), BN_DEF(0x9B56F39A,  0x0EF8AC50),
	BN_DEF(0x79F7F439,  0xF15344ED), BN_DEF(0x707345BB,  0xCC278638),
	BN_DEF(0x3FABE49A,  0xDAAB89AF), BN_DEF(0x9EF68D79,  0x42B1B2AA),
	BN_DEF(0xAF833768,  0x9219FA8F), BN_DEF(0xEAFEB2B0,  0x69EF8F6A),
	BN_DEF(0x576230BD,  0x7B40D901), BN_DEF(0xB1863AEC,  0xBE97F1B1),
	BN_DEF(0x124D9F7C,  0xE649CEE7), BN_DEF(0x8A3219FD,  0xD4F09B20),
	BN_DEF(0xE7169B4A,  0xEC5CE2C1), BN_DEF(0x139E9E78,  0x57EE2B10),
	BN_DEF(0x515DA54D,  0xD6FC2A2C), BN_DEF(0xFFFFFFFF,  0x7FFFFFFF),
};

static const BN_ULONG ffdhe3072_p[] = {
	BN_DEF(0xFFFFFFFF, 0xFFFFFFFF), BN_DEF(0x66C62E37, 0x25E41D2B),
	BN_DEF(0x3FD59D7C, 0x3C1B20EE), BN_DEF(0xFA53DDEF, 0x0ABCD06B),
	BN_DEF(0xD5C4484E, 0x1DBF9A42), BN_DEF(0x9B0DEADA, 0xABC52197),
	BN_DEF(0x22363A0D, 0xE86D2BC5), BN_DEF(0x9C9DF69E, 0x5CAE82AB),
	BN_DEF(0x71F54BFF, 0x64F2E21E), BN_DEF(0xE2D74DD3, 0xF4FD4452),
	BN_DEF(0xBC437944, 0xB4130C93), BN_DEF(0x85139270, 0xAEFE1309),
	BN_DEF(0xC186D91C, 0x598CB0FA), BN_DEF(0x91F7F7EE, 0x7AD91D26),
	BN_DEF(0xD6E6C907, 0x61B46FC9), BN_DEF(0xF99C0238, 0xBC34F4DE),
	BN_DEF(0x6519035B, 0xDE355B3B), BN_DEF(0x611FCFDC, 0x886B4238),
	BN_DEF(0xC1B2EFFA, 0xC6F34A26), BN_DEF(0x7D1683B2, 0xC58EF183),
	BN_DEF(0x2EC22005, 0x3BB5FCBC), BN_DEF(0x4C6FAD73, 0xC3FE3B1B),
	BN_DEF(0xEEF28183, 0x8E4F1232), BN_DEF(0xE98583FF, 0x9172FE9C),
	BN_DEF(0x28342F61, 0xC03404CD), BN_DEF(0xCDF7E2EC, 0x9E02FCE1),
	BN_DEF(0xEE0A6D70, 0x0B07A7C8), BN_DEF(0x6372BB19, 0xAE56EDE7),
	BN_DEF(0xDE394DF4, 0x1D4F42A3), BN_DEF(0x60D7F468, 0xB96ADAB7),
	BN_DEF(0xB2C8E3FB, 0xD108A94B), BN_DEF(0xB324FB61, 0xBC0AB182),
	BN_DEF(0x483A797A, 0x30ACCA4F), BN_DEF(0x36ADE735, 0x1DF158A1),
	BN_DEF(0xF3EFE872, 0xE2A689DA), BN_DEF(0xE0E68B77, 0x984F0C70),
	BN_DEF(0x7F57C935, 0xB557135E), BN_DEF(0x3DED1AF3, 0x85636555),
	BN_DEF(0x5F066ED0, 0x2433F51F), BN_DEF(0xD5FD6561, 0xD3DF1ED5),
	BN_DEF(0xAEC4617A, 0xF681B202), BN_DEF(0x630C75D8, 0x7D2FE363),
	BN_DEF(0x249B3EF9, 0xCC939DCE), BN_DEF(0x146433FB, 0xA9E13641),
	BN_DEF(0xCE2D3695, 0xD8B9C583), BN_DEF(0x273D3CF1, 0xAFDC5620),
	BN_DEF(0xA2BB4A9A, 0xADF85458), BN_DEF(0xFFFFFFFF, 0xFFFFFFFF)
};
/* q = (p - 1) / 2 */
static const BN_ULONG ffdhe3072_q[] = {
	BN_DEF(0xFFFFFFFF,  0xFFFFFFFF), BN_DEF(0xB363171B,  0x12F20E95),
	BN_DEF(0x1FEACEBE,  0x9E0D9077), BN_DEF(0xFD29EEF7,  0x055E6835),
	BN_DEF(0x6AE22427,  0x0EDFCD21), BN_DEF(0xCD86F56D,  0xD5E290CB),
	BN_DEF(0x911B1D06,  0x743695E2), BN_DEF(0xCE4EFB4F,  0xAE574155),
	BN_DEF(0x38FAA5FF,  0xB279710F), BN_DEF(0x716BA6E9,  0x7A7EA229),
	BN_DEF(0xDE21BCA2,  0x5A098649), BN_DEF(0xC289C938,  0x577F0984),
	BN_DEF(0x60C36C8E,  0x2CC6587D), BN_DEF(0x48FBFBF7,  0xBD6C8E93),
	BN_DEF(0xEB736483,  0x30DA37E4), BN_DEF(0x7CCE011C,  0xDE1A7A6F),
	BN_DEF(0xB28C81AD,  0x6F1AAD9D), BN_DEF(0x308FE7EE,  0x4435A11C),
	BN_DEF(0x60D977FD,  0x6379A513), BN_DEF(0xBE8B41D9,  0xE2C778C1),
	BN_DEF(0x17611002,  0x9DDAFE5E), BN_DEF(0xA637D6B9,  0xE1FF1D8D),
	BN_DEF(0x777940C1,  0xC7278919), BN_DEF(0x74C2C1FF,  0xC8B97F4E),
	BN_DEF(0x941A17B0,  0x601A0266), BN_DEF(0xE6FBF176,  0x4F017E70),
	BN_DEF(0x770536B8,  0x8583D3E4), BN_DEF(0xB1B95D8C,  0x572B76F3),
	BN_DEF(0xEF1CA6FA,  0x0EA7A151), BN_DEF(0xB06BFA34,  0xDCB56D5B),
	BN_DEF(0xD96471FD,  0xE88454A5), BN_DEF(0x59927DB0,  0x5E0558C1),
	BN_DEF(0xA41D3CBD,  0x98566527), BN_DEF(0x9B56F39A,  0x0EF8AC50),
	BN_DEF(0x79F7F439,  0xF15344ED), BN_DEF(0x707345BB,  0xCC278638),
	BN_DEF(0x3FABE49A,  0xDAAB89AF), BN_DEF(0x9EF68D79,  0x42B1B2AA),
	BN_DEF(0xAF833768,  0x9219FA8F), BN_DEF(0xEAFEB2B0,  0x69EF8F6A),
	BN_DEF(0x576230BD,  0x7B40D901), BN_DEF(0xB1863AEC,  0xBE97F1B1),
	BN_DEF(0x124D9F7C,  0xE649CEE7), BN_DEF(0x8A3219FD,  0xD4F09B20),
	BN_DEF(0xE7169B4A,  0xEC5CE2C1), BN_DEF(0x139E9E78,  0x57EE2B10),
	BN_DEF(0x515DA54D,  0xD6FC2A2C), BN_DEF(0xFFFFFFFF,  0x7FFFFFFF),
};

static const BN_ULONG ffdhe4096_p[] = {
	BN_DEF(0xFFFFFFFF, 0xFFFFFFFF), BN_DEF(0x5E655F6A, 0xC68A007E),
	BN_DEF(0xF44182E1, 0x4DB5A851), BN_DEF(0x7F88A46B, 0x8EC9B55A),
	BN_DEF(0xCEC97DCF, 0x0A8291CD), BN_DEF(0xF98D0ACC, 0x2A4ECEA9),
	BN_DEF(0x7140003C, 0x1A1DB93D), BN_DEF(0x33CB8B7A, 0x092999A3),
	BN_DEF(0x71AD0038, 0x6DC778F9), BN_DEF(0x918130C4, 0xA907600A),
	BN_DEF(0x2D9E6832, 0xED6A1E01), BN_DEF(0xEFB4318A, 0x7135C886),
	BN_DEF(0x7E31CC7A, 0x87F55BA5), BN_DEF(0x55034004, 0x7763CF1D),
	BN_DEF(0xD69F6D18, 0xAC7D5F42), BN_DEF(0xE58857B6, 0x7930E9E4),
	BN_DEF(0x164DF4FB, 0x6E6F52C3), BN_DEF(0x669E1EF1, 0x25E41D2B),
	BN_DEF(0x3FD59D7C, 0x3C1B20EE), BN_DEF(0xFA53DDEF, 0x0ABCD06B),
	BN_DEF(0xD5C4484E, 0x1DBF9A42), BN_DEF(0x9B0DEADA, 0xABC52197),
	BN_DEF(0x22363A0D, 0xE86D2BC5), BN_DEF(0x9C9DF69E, 0x5CAE82AB),
	BN_DEF(0x71F54BFF, 0x64F2E21E), BN_DEF(0xE2D74DD3, 0xF4FD4452),
	BN_DEF(0xBC437944, 0xB4130C93), BN_DEF(0x85139270, 0xAEFE1309),
	BN_DEF(0xC186D91C, 0x598CB0FA), BN_DEF(0x91F7F7EE, 0x7AD91D26),
	BN_DEF(0xD6E6C907, 0x61B46FC9), BN_DEF(0xF99C0238, 0xBC34F4DE),
	BN_DEF(0x6519035B, 0xDE355B3B), BN_DEF(0x611FCFDC, 0x886B4238),
	BN_DEF(0xC1B2EFFA, 0xC6F34A26), BN_DEF(0x7D1683B2, 0xC58EF183),
	BN_DEF(0x2EC22005, 0x3BB5FCBC), BN_DEF(0x4C6FAD73, 0xC3FE3B1B),
	BN_DEF(0xEEF28183, 0x8E4F1232), BN_DEF(0xE98583FF, 0x9172FE9C),
	BN_DEF(0x28342F61, 0xC03404CD), BN_DEF(0xCDF7E2EC, 0x9E02FCE1),
	BN_DEF(0xEE0A6D70, 0x0B07A7C8), BN_DEF(0x6372BB19, 0xAE56EDE7),
	BN_DEF(0xDE394DF4, 0x1D4F42A3), BN_DEF(0x60D7F468, 0xB96ADAB7),
	BN_DEF(0xB2C8E3FB, 0xD108A94B), BN_DEF(0xB324FB61, 0xBC0AB182),
	BN_DEF(0x483A797A, 0x30ACCA4F), BN_DEF(0x36ADE735, 0x1DF158A1),
	BN_DEF(0xF3EFE872, 0xE2A689DA), BN_DEF(0xE0E68B77, 0x984F0C70),
	BN_DEF(0x7F57C935, 0xB557135E), BN_DEF(0x3DED1AF3, 0x85636555),
	BN_DEF(0x5F066ED0, 0x2433F51F), BN_DEF(0xD5FD6561, 0xD3DF1ED5),
	BN_DEF(0xAEC4617A, 0xF681B202), BN_DEF(0x630C75D8, 0x7D2FE363),
	BN_DEF(0x249B3EF9, 0xCC939DCE), BN_DEF(0x146433FB, 0xA9E13641),
	BN_DEF(0xCE2D3695, 0xD8B9C583), BN_DEF(0x273D3CF1, 0xAFDC5620),
	BN_DEF(0xA2BB4A9A, 0xADF85458), BN_DEF(0xFFFFFFFF, 0xFFFFFFFF)
};
/* q = (p - 1) / 2 */
static const BN_ULONG ffdhe4096_q[] = {
	BN_DEF(0xFFFFFFFF,  0x7FFFFFFF), BN_DEF(0x2F32AFB5,  0xE345003F),
	BN_DEF(0xFA20C170,  0xA6DAD428), BN_DEF(0x3FC45235,  0xC764DAAD),
	BN_DEF(0xE764BEE7,  0x054148E6), BN_DEF(0xFCC68566,  0x15276754),
	BN_DEF(0xB8A0001E,  0x0D0EDC9E), BN_DEF(0x99E5C5BD,  0x0494CCD1),
	BN_DEF(0xB8D6801C,  0x36E3BC7C), BN_DEF(0x48C09862,  0x5483B005),
	BN_DEF(0x96CF3419,  0x76B50F00), BN_DEF(0x77DA18C5,  0x389AE443),
	BN_DEF(0xBF18E63D,  0x43FAADD2), BN_DEF(0xAA81A002,  0x3BB1E78E),
	BN_DEF(0x6B4FB68C,  0x563EAFA1), BN_DEF(0x72C42BDB,  0xBC9874F2),
	BN_DEF(0x8B26FA7D,  0xB737A961), BN_DEF(0xB34F0F78,  0x12F20E95),
	BN_DEF(0x1FEACEBE,  0x9E0D9077), BN_DEF(0xFD29EEF7,  0x055E6835),
	BN_DEF(0x6AE22427,  0x0EDFCD21), BN_DEF(0xCD86F56D,  0xD5E290CB),
	BN_DEF(0x911B1D06,  0x743695E2), BN_DEF(0xCE4EFB4F,  0xAE574155),
	BN_DEF(0x38FAA5FF,  0xB279710F), BN_DEF(0x716BA6E9,  0x7A7EA229),
	BN_DEF(0xDE21BCA2,  0x5A098649), BN_DEF(0xC289C938,  0x577F0984),
	BN_DEF(0x60C36C8E,  0x2CC6587D), BN_DEF(0x48FBFBF7,  0xBD6C8E93),
	BN_DEF(0xEB736483,  0x30DA37E4), BN_DEF(0x7CCE011C,  0xDE1A7A6F),
	BN_DEF(0xB28C81AD,  0x6F1AAD9D), BN_DEF(0x308FE7EE,  0x4435A11C),
	BN_DEF(0x60D977FD,  0x6379A513), BN_DEF(0xBE8B41D9,  0xE2C778C1),
	BN_DEF(0x17611002,  0x9DDAFE5E), BN_DEF(0xA637D6B9,  0xE1FF1D8D),
	BN_DEF(0x777940C1,  0xC7278919), BN_DEF(0x74C2C1FF,  0xC8B97F4E),
	BN_DEF(0x941A17B0,  0x601A0266), BN_DEF(0xE6FBF176,  0x4F017E70),
	BN_DEF(0x770536B8,  0x8583D3E4), BN_DEF(0xB1B95D8C,  0x572B76F3),
	BN_DEF(0xEF1CA6FA,  0x0EA7A151), BN_DEF(0xB06BFA34,  0xDCB56D5B),
	BN_DEF(0xD96471FD,  0xE88454A5), BN_DEF(0x59927DB0,  0x5E0558C1),
	BN_DEF(0xA41D3CBD,  0x98566527), BN_DEF(0x9B56F39A,  0x0EF8AC50),
	BN_DEF(0x79F7F439,  0xF15344ED), BN_DEF(0x707345BB,  0xCC278638),
	BN_DEF(0x3FABE49A,  0xDAAB89AF), BN_DEF(0x9EF68D79,  0x42B1B2AA),
	BN_DEF(0xAF833768,  0x9219FA8F), BN_DEF(0xEAFEB2B0,  0x69EF8F6A),
	BN_DEF(0x576230BD,  0x7B40D901), BN_DEF(0xB1863AEC,  0xBE97F1B1),
	BN_DEF(0x124D9F7C,  0xE649CEE7), BN_DEF(0x8A3219FD,  0xD4F09B20),
	BN_DEF(0xE7169B4A,  0xEC5CE2C1), BN_DEF(0x139E9E78,  0x57EE2B10),
	BN_DEF(0x515DA54D,  0xD6FC2A2C), BN_DEF(0xFFFFFFFF,  0x7FFFFFFF),
};

make_dh_bn(dh1024_160_p);
make_dh_bn(dh1024_160_q);
make_dh_bn(dh1024_160_g);
make_dh_bn(dh2048_224_p);
make_dh_bn(dh2048_224_q);
make_dh_bn(dh2048_224_g);
make_dh_bn(dh2048_256_p);
make_dh_bn(dh2048_256_q);
make_dh_bn(dh2048_256_g);

make_dh_bn(ffdhe2048_p);
make_dh_bn(ffdhe2048_q);
make_dh_bn(ffdhe3072_p);
make_dh_bn(ffdhe3072_q);
make_dh_bn(ffdhe4096_p);
make_dh_bn(ffdhe4096_q);

# ifndef FIPS_MODULE
make_dh_bn(modp_1536_p);
make_dh_bn(modp_1536_q);
# endif
make_dh_bn(modp_2048_p);
make_dh_bn(modp_2048_q);
make_dh_bn(modp_3072_p);
make_dh_bn(modp_3072_q);
make_dh_bn(modp_4096_p);
make_dh_bn(modp_4096_q);

int ossl_ffc_params_set_seed(FFC_PARAMS *params,
			     const unsigned char *seed, size_t seedlen)
{
	if (params == NULL)
		return 0;

	if (params->seed != NULL) {
		if (params->seed == seed)
			return 1;
		OPENSSL_free(params->seed);
	}

	if (seed != NULL && seedlen > 0) {
		params->seed = OPENSSL_memdup(seed, seedlen);
		if (params->seed == NULL)
			return 0;
		params->seedlen = seedlen;
	} else {
		params->seed = NULL;
		params->seedlen = 0;
	}

	return 1;
}

static int ffc_bn_cpy(BIGNUM **dst, const BIGNUM *src)
{
	BIGNUM *a;

	/*
	 * If source is read only just copy the pointer, so
	 * we don't have to reallocate it.
	 */
	if (src == NULL) {
		a = NULL;
		goto end;
	}

	if (BN_get_flags(src, BN_FLG_STATIC_DATA) && !BN_get_flags(src, BN_FLG_MALLOCED)) {
		a = (BIGNUM *)src;
		goto end;
	}

	a = BN_dup(src);
	if (a == NULL)
		return 0;

end:
	BN_clear_free(*dst);
	*dst = a;

	return 1;
}

int ossl_ffc_params_copy(FFC_PARAMS *dst, const FFC_PARAMS *src)
{
	if (src == NULL || dst == NULL)
		return 0;

	if (!ffc_bn_cpy(&dst->p, src->p) ||
	    !ffc_bn_cpy(&dst->g, src->g) ||
	    !ffc_bn_cpy(&dst->q, src->q) ||
	    !ffc_bn_cpy(&dst->j, src->j))
		return 0;

	OPENSSL_free(dst->seed);
	dst->seedlen = src->seedlen;
	if (src->seed != NULL) {
		dst->seed = OPENSSL_memdup(src->seed, src->seedlen);
		if  (dst->seed == NULL)
			return 0;
	} else {
		dst->seed = NULL;
	}
	dst->nid = src->nid;
	dst->pcounter = src->pcounter;
	dst->h = src->h;
	dst->gindex = src->gindex;
	dst->flags = src->flags;

	return 1;
}

void ossl_ffc_params_get0_pqg(const FFC_PARAMS *d, const BIGNUM **p,
			      const BIGNUM **q, const BIGNUM **g)
{
	if (d == NULL)
		return;

	if (p != NULL)
		*p = d->p;

	if (q != NULL)
		*q = d->q;

	if (g != NULL)
		*g = d->g;
}

const DH_NAMED_GROUP *ossl_ffc_uid_to_dh_named_group(int uid)
{
	size_t i;

	for (i = 0; i < OSSL_NELEM(dh_named_groups); ++i) {
		if (dh_named_groups[i].uid == uid)
			return &dh_named_groups[i];
	}

	return NULL;
}


void ossl_ffc_params_set0_pqg(FFC_PARAMS *d, BIGNUM *p, BIGNUM *q, BIGNUM *g)
{
	if (d == NULL)
		return;

	if (p != NULL && p != d->p) {
		BN_free(d->p);
		d->p = p;
	}

	if (q != NULL && q != d->q) {
		BN_free(d->q);
		d->q = q;
	}

	if (g != NULL && g != d->g) {
		BN_free(d->g);
		d->g = g;
	}
}

int ossl_ffc_named_group_set(FFC_PARAMS *ffc, const DH_NAMED_GROUP *group)
{
	if (ffc == NULL || group == NULL)
		return 0;

	ossl_ffc_params_set0_pqg(ffc, (BIGNUM *)group->p, (BIGNUM *)group->q,
				(BIGNUM *)group->g);
	ffc->keylength = group->keylength;

	/* flush the cached nid, The DH layer is responsible for caching */
	ffc->nid = NID_undef;

	return 1;
}

int ossl_ffc_named_group_get_uid(const DH_NAMED_GROUP *group)
{
	if (group == NULL)
		return NID_undef;

	return group->uid;
}

void ossl_ffc_params_set_gindex(FFC_PARAMS *params, int index)
{
	if (params == NULL)
		return;

	params->gindex = index;
}

void ossl_ffc_params_set_pcounter(FFC_PARAMS *params, int index)
{
	if (params == NULL)
		return;

	params->pcounter = index;
}

void ossl_ffc_params_set_h(FFC_PARAMS *params, int index)
{
	if (params == NULL)
		return;

	params->h = index;
}

int ossl_ffc_set_digest(FFC_PARAMS *params, const char *alg, const char *props)
{
	if (params == NULL)
		return 0;

	params->mdname = alg;
	params->mdprops = props;

	return 1;
}

void ossl_ffc_params_enable_flags(FFC_PARAMS *params, unsigned int flags,
				  int enable)
{
	if (params == NULL)
		return;

	if (enable)
		params->flags |= flags;
	else
		params->flags &= ~flags;
}

int ossl_ffc_params_cmp(const FFC_PARAMS *a, const FFC_PARAMS *b, int ignore_q)
{
	if (a == NULL || b == NULL)
		return 0;

	return BN_cmp(a->p, b->p) == 0
		&& BN_cmp(a->g, b->g) == 0
		&& (ignore_q || BN_cmp(a->q, b->q) == 0); /* Note: q may be NULL */
}

void ossl_ffc_params_init(FFC_PARAMS *params)
{
	if (params == NULL)
		return;

	memset(params, 0, sizeof(*params));
	params->pcounter = -1;
	params->gindex = FFC_UNVERIFIABLE_GINDEX;
	params->flags = FFC_PARAM_FLAG_VALIDATE_PQG;
}

void ossl_ffc_params_cleanup(FFC_PARAMS *params)
{
	if (params == NULL)
		return;

	BN_free(params->p);
	BN_free(params->q);
	BN_free(params->g);
	BN_free(params->j);
	OPENSSL_free(params->seed);
	ossl_ffc_params_init(params);
}

/* FIPS186-4 A.2.1 Unverifiable Generation of Generator g */
static int generate_unverifiable_g(BN_CTX *ctx, BN_MONT_CTX *mont, BIGNUM *g,
				   BIGNUM *hbn, const BIGNUM *p,
				   const BIGNUM *e, const BIGNUM *pm1,
				   int *hret)
{
	int h = 2;

	/* Step (2): choose h (where 1 < h)*/
	if (!BN_set_word(hbn, h))
		return 0;

	for (;;) {
		/* Step (3): g = h^e % p */
		if (!BN_mod_exp_mont(g, hbn, e, p, ctx, mont))
			return 0;
		/* Step (4): Finish if g > 1 */
		if (BN_cmp(g, BN_value_one()) > 0)
			break;

		/* Step (2) Choose any h in the range 1 < h < (p-1) */
		if (!BN_add_word(hbn, 1) || BN_cmp(hbn, pm1) >= 0)
			return 0;
		++h;
	}
	*hret = h;

	return 1;
}

/* Generation of p is the same for FIPS 186-4 & FIPS 186-2 */
static int generate_p(BN_CTX *ctx, const EVP_MD *evpmd, int max_counter, int n,
		      unsigned char *buf, size_t buf_len, const BIGNUM *q,
		      BIGNUM *p, int L, BN_GENCB *cb, int *counter,
		      int *res)
{
	unsigned char md[EVP_MAX_MD_SIZE];
	BIGNUM *W, *X, *tmp, *c, *test;
	int ret = -1;
	int i, j, k, r;
	int mdsize;

	BN_CTX_start(ctx);
	W = BN_CTX_get(ctx);
	X = BN_CTX_get(ctx);
	c = BN_CTX_get(ctx);
	test = BN_CTX_get(ctx);
	tmp = BN_CTX_get(ctx);
	if (tmp == NULL)
		goto err;

	if (!BN_lshift(test, BN_value_one(), L - 1))
		goto err;

	mdsize = EVP_MD_get_size(evpmd);
	if (mdsize <= 0)
		goto err;

	/*
	 * A.1.1.2 Step (10) AND
	 * A.1.1.2 Step (12)
	 * offset = 1 (this is handled below)
	 */
	/*
	 * A.1.1.2 Step (11) AND
	 * A.1.1.3 Step (13)
	 */
	for (i = 0; i <= max_counter; i++) {
		if ((i != 0) && !BN_GENCB_call(cb, 0, i))
			goto err;

		BN_zero(W);
		/* seed_tmp buffer contains "seed + offset - 1" */
		for (j = 0; j <= n; j++) {
			/* obtain "seed + offset + j" by incrementing by 1: */
			for (k = (int)buf_len - 1; k >= 0; k--) {
				buf[k]++;
				if (buf[k] != 0)
					break;
			}
			/*
			 * A.1.1.2 Step (11.1) AND
			 * A.1.1.3 Step (13.1)
			 * tmp = V(j) = Hash((seed + offset + j) % 2^seedlen)
			 */
			if (!EVP_Digest(buf, buf_len, md, NULL, evpmd, NULL) ||
			    (BN_bin2bn(md, mdsize, tmp) == NULL) ||
			    /*
			     * A.1.1.2 Step (11.2)
			     * A.1.1.3 Step (13.2)
			     * W += V(j) * 2^(outlen * j)
			     */
			    !BN_lshift(tmp, tmp, (mdsize << 3) * j) ||
			    !BN_add(W, W, tmp))
				goto err;
		}

		/*
		 * A.1.1.2 Step (11.3) AND
		 * A.1.1.3 Step (13.3)
		 * X = W + 2^(L-1) where W < 2^(L-1)
		 */
		if (!BN_mask_bits(W, L - 1) ||
		    !BN_copy(X, W) ||
		    !BN_add(X, X, test) ||
		    /*
		     * A.1.1.2 Step (11.4) AND
		     * A.1.1.3 Step (13.4)
		     * c = X mod 2q
		     */
		    !BN_lshift1(tmp, q) ||
		    !BN_mod(c, X, tmp, ctx) ||
		    /*
		     * A.1.1.2 Step (11.5) AND
		     * A.1.1.3 Step (13.5)
		     * p = X - (c - 1)
		     */
		    !BN_sub(tmp, c, BN_value_one()) ||
		    !BN_sub(p, X, tmp))
			goto err;

		/*
		 * A.1.1.2 Step (11.6) AND
		 * A.1.1.3 Step (13.6)
		 * if (p < 2 ^ (L-1)) continue
		 * This makes sure the top bit is set.
		 */
		if (BN_cmp(p, test) >= 0) {
			/*
			 * A.1.1.2 Step (11.7) AND
			 * A.1.1.3 Step (13.7)
			 * Test if p is prime
			 * (This also makes sure the bottom bit is set)
			 */
			r = BN_check_prime(p, ctx, cb);
			/* A.1.1.2 Step (11.8) : Return if p is prime */
			if (r > 0) {
				*counter = i;
				ret = 1;   /* return success */
				goto err;
			}
			if (r != 0)
				goto err;
		}
		/* Step (11.9) : offset = offset + n + 1 is done auto-magically */
	}
	/* No prime P found */
	ret = 0;
	*res |= FFC_CHECK_P_NOT_PRIME;

err:
	BN_CTX_end(ctx);
	return ret;
}

static OSSL_LIB_CTX *ossl_bn_get_libctx(BN_CTX *ctx)
{
	if (ctx == NULL)
		return NULL;

	return ctx->libctx;
}

static int generate_q_fips186_2(BN_CTX *ctx, BIGNUM *q, const EVP_MD *evpmd,
				unsigned char *buf, unsigned char *seed,
				size_t qsize, int generate_seed, int *retm,
				int *res, BN_GENCB *cb)
{
	OSSL_LIB_CTX *libctx = ossl_bn_get_libctx(ctx);
	unsigned char buf2[EVP_MAX_MD_SIZE];
	unsigned char md[EVP_MAX_MD_SIZE];
	int i, r, ret = 0, m = *retm;

	/* find q */
	for (;;) {
		/* step 1 */
		if (!BN_GENCB_call(cb, 0, m++))
			goto err;

		if (generate_seed && RAND_bytes_ex(libctx, seed, qsize, 0) <= 0)
			goto err;

		memcpy(buf, seed, qsize);
		memcpy(buf2, seed, qsize);

		/* precompute "SEED + 1" for step 7: */
		for (i = (int)qsize - 1; i >= 0; i--) {
			buf[i]++;
			if (buf[i] != 0)
				break;
		}

		/* step 2 */
		if (!EVP_Digest(seed, qsize, md, NULL, evpmd, NULL))
			goto err;
		if (!EVP_Digest(buf, qsize, buf2, NULL, evpmd, NULL))
			goto err;
		for (i = 0; i < (int)qsize; i++)
			md[i] ^= buf2[i];

		/* step 3 */
		md[0] |= 0x80;
		md[qsize - 1] |= 0x01;
		if (!BN_bin2bn(md, (int)qsize, q))
			goto err;

		/* step 4 */
		r = BN_check_prime(q, ctx, cb);
		if (r > 0) {
			/* Found a prime */
			ret = 1;
			goto err;
		}
		if (r != 0)
			goto err; /* Exit if error */
		/* Try another iteration if it wasnt prime - was in old code.. */
		generate_seed = 1;
	}
err:
	*retm = m;
	return ret;
}

/*
 * Verify that the passed in L, N pair for DH or DSA is valid.
 * Returns 0 if invalid, otherwise it returns the security strength.
 */

#ifdef FIPS_MODULE
static int ffc_validate_LN(size_t L, size_t N, int type, int verify)
{
	if (type == FFC_PARAM_TYPE_DH) {
		/* Valid DH L,N parameters from SP800-56Ar3 5.5.1 Table 1 */
		if (L == L_P_2048BITS && (N == N_Q_224BITS || N == N_Q_256BITS))
			return SECURITY_STR_112BITS;
# ifndef OPENSSL_NO_DH
		ERR_raise(ERR_LIB_DH, DH_R_BAD_FFC_PARAMETERS);
# endif
	} else if (type == FFC_PARAM_TYPE_DSA) {
		/* Valid DSA L,N parameters from FIPS 186-4 Section 4.2 */
		/* In fips mode 1024/160 can only be used for verification */
		if (verify && L == L_P_1024BITS && N == N_Q_160BITS)
			return SECURITY_STR_80BITS;
		if (L == L_P_2048BITS && (N == N_Q_224BITS || N == N_Q_256BITS))
			return SECURITY_STR_112BITS;
		if (L == L_P_3072BITS && N == N_Q_256BITS)
			return SECURITY_STR_128BITS;
# ifndef OPENSSL_NO_DSA
		ERR_raise(ERR_LIB_DSA, DSA_R_BAD_FFC_PARAMETERS);
# endif
	}

	return 0;
}
#else
static int ffc_validate_LN(size_t L, size_t N, int type, int verify)
{
	if (type == FFC_PARAM_TYPE_DH) {
		/* Allow legacy 1024/160 in non fips mode */
		if (L == L_P_1024BITS && N == N_Q_160BITS)
			return SECURITY_STR_80BITS;
		/* Valid DH L,N parameters from SP800-56Ar3 5.5.1 Table 1 */
		if (L == L_P_2048BITS && (N == N_Q_224BITS || N == N_Q_256BITS))
			return SECURITY_STR_112BITS;
# ifndef OPENSSL_NO_DH
		ERR_raise(ERR_LIB_DH, DH_R_BAD_FFC_PARAMETERS);
# endif
	} else if (type == FFC_PARAM_TYPE_DSA) {
		if (L >= L_P_3072BITS && N >= N_Q_256BITS)
			return SECURITY_STR_128BITS;
		if (L >= L_P_2048BITS && N >= N_Q_224BITS)
			return SECURITY_STR_112BITS;
		if (L >= L_P_1024BITS && N >= N_Q_160BITS)
			return SECURITY_STR_80BITS;
# ifndef OPENSSL_NO_DSA
		ERR_raise(ERR_LIB_DSA, DSA_R_BAD_FFC_PARAMETERS);
# endif
	}

	return 0;
}
#endif /* FIPS_MODULE */

static int ossl_ffc_params_set_validate_params(FFC_PARAMS *params,
					       const unsigned char *seed,
					       size_t seedlen, int counter)
{
	if (!ossl_ffc_params_set_seed(params, seed, seedlen))
		return 0;
	params->pcounter = counter;

	return 1;
}

static const char *default_mdname(size_t N)
{
	if (N == N_Q_160BITS)
		return "SHA1";
	else if (N == N_Q_224BITS)
		return "SHA-224";
	else if (N == N_Q_256BITS)
		return "SHA-256";

	return NULL;
}

/* FIPS186-4 A.2.2 Unverifiable partial validation of Generator g */
static int ossl_ffc_params_validate_unverifiable_g(BN_CTX *ctx, BN_MONT_CTX *mont,
						   const BIGNUM *p, const BIGNUM *q,
						   const BIGNUM *g, BIGNUM *tmp,
						   int *ret)
{
	/*
	 * A.2.2 Step (1) AND
	 * A.2.4 Step (2)
	 * Verify that 2 <= g <= (p - 1)
	 */
	if (BN_cmp(g, BN_value_one()) <= 0 || BN_cmp(g, p) >= 0) {
		*ret |= FFC_ERROR_NOT_SUITABLE_GENERATOR;
		return 0;
	}

	/*
	 * A.2.2 Step (2) AND
	 * A.2.4 Step (3)
	 * Check g^q mod p = 1
	 */
	if (!BN_mod_exp_mont(tmp, g, q, p, ctx, mont))
		return 0;
	if (BN_cmp(tmp, BN_value_one()) != 0) {
		*ret |= FFC_ERROR_NOT_SUITABLE_GENERATOR;
		return 0;
	}

	return 1;
}

/* Note this function is only used for verification in fips mode */
int ossl_ffc_params_FIPS186_2_gen_verify(OSSL_LIB_CTX *libctx,
					 FFC_PARAMS *params, int mode, int type,
					 size_t L, size_t N, int *res,
					 BN_GENCB *cb)
{
	BIGNUM *r0, *test, *tmp, *g = NULL, *q = NULL, *p = NULL;
	int counter = 0, pcounter = 0, use_random_seed;
	int ok = FFC_PARAM_RET_STATUS_FAILED;
	unsigned char seed[SHA256_DIGEST_LENGTH];
	unsigned char buf[SHA256_DIGEST_LENGTH];
	unsigned char *seed_in = params->seed;
	size_t seed_len = params->seedlen;
	int verify = (mode == FFC_PARAM_MODE_VERIFY);
	unsigned int flags = verify ? params->flags : 0;
	const char *def_name;
	BN_MONT_CTX *mont = NULL;
	BN_CTX *ctx = NULL;
	EVP_MD *md = NULL;
	int hret = -1;
	size_t qsize;
	int n = 0, m = 0;
	int rv;

	*res = 0;

	if (params->mdname != NULL) {
		md = EVP_MD_fetch(libctx, params->mdname, params->mdprops);
	} else {
		if (N == 0) {
			if (L >= L_P_2048BITS)
				N = TRANS_BYTES_TO_BITS(SHA256_DIGEST_LENGTH);
			else
				N = TRANS_BYTES_TO_BITS(SHA_DIGEST_LENGTH);
		}

		def_name = default_mdname(N);
		if (def_name == NULL) {
			*res = FFC_CHECK_INVALID_Q_VALUE;
			goto err;
		}
		md = EVP_MD_fetch(libctx, def_name, params->mdprops);
	}
	if (md == NULL)
		goto err;

	if (N == 0)
		N = TRANS_BYTES_TO_BITS(EVP_MD_get_size(md));

	qsize = TRANS_BITS_TO_BYTES(N);

	/*
	 * The original spec allowed L = 512 + 64*j (j = 0.. 8)
	 * https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf
	 * says that 512 can be used for legacy verification.
	 */
	if (L < L_P_512BITS) {
		*res = FFC_CHECK_BAD_LN_PAIR;
		goto err;
	}
	if (qsize != SHA_DIGEST_LENGTH &&
	    qsize != SHA224_DIGEST_LENGTH &&
	    qsize != SHA256_DIGEST_LENGTH) {
		/* invalid q size */
		*res = FFC_CHECK_INVALID_Q_VALUE;
		goto err;
	}
	/* Padding 'L' to the  integer multiple of 64 */
	L = PADDING_LEN(L);

	if (seed_in != NULL) {
		if (seed_len < qsize) {
			*res = FFC_CHECK_INVALID_SEED_SIZE;
			goto err;
		}
		/* Only consume as much seed as is expected. */
		if (seed_len > qsize)
			seed_len = qsize;
		memcpy(seed, seed_in, seed_len);
	}

	ctx = BN_CTX_new_ex(libctx);
	if (ctx == NULL)
		goto err;

	BN_CTX_start(ctx);

	r0 = BN_CTX_get(ctx);
	g = BN_CTX_get(ctx);
	q = BN_CTX_get(ctx);
	p = BN_CTX_get(ctx);
	tmp = BN_CTX_get(ctx);
	test = BN_CTX_get(ctx);
	if (test == NULL)
		goto err;

	if (!BN_lshift(test, BN_value_one(), L - 1))
		goto err;

	if (!verify) {
		/* For generation: p & q must both be NULL or NON-NULL */
		if ((params->p != NULL) != (params->q != NULL)) {
			*res = FFC_CHECK_INVALID_PQ;
			goto err;
		}
	} else {
		if ((flags & FFC_PARAM_FLAG_VALIDATE_PQ) != 0) {
			/* Validation of p,q requires seed and counter to be valid */
			if (seed_in == NULL || params->pcounter < 0) {
				*res = FFC_CHECK_MISSING_SEED_OR_COUNTER;
				goto err;
			}
		}
		if ((flags & FFC_PARAM_FLAG_VALIDATE_G) != 0) {
			/* validation of g also requires g to be set */
			if (params->g == NULL) {
				*res = FFC_CHECK_INVALID_G;
				goto err;
			}
		}
	}

	if (params->p != NULL && ((flags & FFC_PARAM_FLAG_VALIDATE_PQ) == 0)) {
		/* p and q already exists so only generate g */
		p = params->p;
		q = params->q;
		goto g_only;
		/* otherwise to validate p and q */
	}

	use_random_seed = (seed_in == NULL);
	for (;;) {
		if (!generate_q_fips186_2(ctx, q, md, buf, seed, qsize,
					use_random_seed, &m, res, cb))
			goto err;

		if (!BN_GENCB_call(cb, GENCB_NEXT, 0))
			goto err;
		if (!BN_GENCB_call(cb, GENCB_RETRY, 0))
			goto err;

		/* step 6 compute the block num with digest length 160 bits */
		n = (L - 1) / 160;
		counter = 4 * L - 1; /* Was 4096 */
		/* Validation requires the counter to be supplied */
		if (verify) {
			if (params->pcounter > counter) {
				*res = FFC_CHECK_INVALID_COUNTER;
				goto err;
			}
			counter = params->pcounter;
		}

		rv = generate_p(ctx, md, counter, n, buf, qsize, q, p, L, cb,
				&pcounter, res);
		if (rv > 0)
			break; /* found it */
		if (rv == -1)
			goto err;
		/* This is what the old code did - probably not a good idea! */
		use_random_seed = 1;
	}

	if (!BN_GENCB_call(cb, GENCB_NEXT, 1))
		goto err;

	if (verify) {
		if (pcounter != counter) {
			*res = FFC_CHECK_COUNTER_MISMATCH;
			goto err;
		}

		if (BN_cmp(p, params->p) != 0) {
			*res = FFC_CHECK_P_MISMATCH;
			goto err;
		}
	}
	/* If validating p & q only then skip the g validation test */
	if ((flags & FFC_PARAM_FLAG_VALIDATE_PQG) == FFC_PARAM_FLAG_VALIDATE_PQ)
		goto pass;

g_only:
	mont = BN_MONT_CTX_new();
	if (mont == NULL)
		goto err;
	if (!BN_MONT_CTX_set(mont, p, ctx))
		goto err;

	if (!verify) {
		/* We now need to generate g */
		/* set test = p - 1 */
		if (!BN_sub(test, p, BN_value_one()))
			goto err;
		/* Set r0 = (p - 1) / q */
		if (!BN_div(r0, NULL, test, q, ctx))
			goto err;
		if (!generate_unverifiable_g(ctx, mont, g, tmp, p, r0, test, &hret))
			goto err;
	} else if (((flags & FFC_PARAM_FLAG_VALIDATE_G) != 0) &&
		   !ossl_ffc_params_validate_unverifiable_g(ctx, mont, p, q,
							    params->g, tmp, res)) {
		goto err;
	}

	if (!BN_GENCB_call(cb, GENCB_RETRY, 1))
		goto err;

	if (!verify) {
		if (p != params->p) {
			BN_free(params->p);
			params->p = BN_dup(p);
		}
		if (q != params->q) {
			BN_free(params->q);
			params->q = BN_dup(q);
		}
		if (g != params->g) {
			BN_free(params->g);
			params->g = BN_dup(g);
		}
		if (params->p == NULL || params->q == NULL || params->g == NULL)
			goto err;
		if (!ossl_ffc_params_set_validate_params(params, seed, qsize, pcounter))
			goto err;
		params->h = hret;
	}
pass:
	if ((flags & FFC_PARAM_FLAG_VALIDATE_G) != 0)
		ok = FFC_PARAM_RET_STATUS_UNVERIFIABLE_G;
	else
		ok = FFC_PARAM_RET_STATUS_SUCCESS;
err:
	if (ctx != NULL)
		BN_CTX_end(ctx);
	BN_CTX_free(ctx);
	BN_MONT_CTX_free(mont);
	EVP_MD_free(md);
	return ok;
}

/* This should no longer be used in FIPS mode */
int ossl_ffc_params_FIPS186_2_generate(OSSL_LIB_CTX *libctx, FFC_PARAMS *params,
				       int type, size_t L, size_t N,
				       int *res, BN_GENCB *cb)
{
	if (!ossl_ffc_params_FIPS186_2_gen_verify(libctx, params,
						  FFC_PARAM_MODE_GENERATE,
						  type, L, N, res, cb))
		return 0;

	ossl_ffc_params_enable_flags(params, FFC_PARAM_FLAG_VALIDATE_LEGACY, 1);

	return 1;
}

static int generate_q_fips186_4(BN_CTX *ctx, BIGNUM *q, const EVP_MD *evpmd,
				int qsize, unsigned char *seed, size_t seedlen,
				int generate_seed, int *retm, int *res,
				BN_GENCB *cb)
{
	int ret = 0, r;
	int m = *retm;
	unsigned char md[EVP_MAX_MD_SIZE];
	int mdsize = EVP_MD_get_size(evpmd);
	unsigned char *pmd;
	OSSL_LIB_CTX *libctx = ossl_bn_get_libctx(ctx);

	/* find q */
	for (;;) {
		if (!BN_GENCB_call(cb, 0, m++))
			goto err;

		/* A.1.1.2 Step (5) : generate seed with size seed_len */
		if (generate_seed
			&& RAND_bytes_ex(libctx, seed, seedlen, 0) <= 0)
			goto err;
		/*
		 * A.1.1.2 Step (6) AND
		 * A.1.1.3 Step (7)
		 * U = Hash(seed) % (2^(N-1))
		 */
		if (!EVP_Digest(seed, seedlen, md, NULL, evpmd, NULL))
			goto err;
		/* Take least significant bits of md */
		if (mdsize > qsize)
			pmd = md + mdsize - qsize;
		else
			pmd = md;
		if (mdsize < qsize)
			memset(md + mdsize, 0, qsize - mdsize);

		/*
		 * A.1.1.2 Step (7) AND
		 * A.1.1.3 Step (8)
		 * q = U + 2^(N-1) + (1 - U %2) (This sets top and bottom bits)
		 */
		pmd[0] |= 0x80;
		pmd[qsize-1] |= 0x01;
		if (!BN_bin2bn(pmd, qsize, q))
			goto err;

		/*
		 * A.1.1.2 Step (8) AND
		 * A.1.1.3 Step (9)
		 * Test if q is prime
		 */
		r = BN_check_prime(q, ctx, cb);
		if (r > 0) {
			ret = 1;
			goto err;
		}
		/*
		 * A.1.1.3 Step (9) : If the provided seed didn't produce a prime q
		 * return an error.
		 */
		if (!generate_seed) {
			*res |= FFC_CHECK_Q_NOT_PRIME;
			goto err;
		}
		if (r != 0)
			goto err;
		/* A.1.1.2 Step (9) : if q is not prime, try another q */
	}

err:
	*retm = m;
	return ret;
}

/*
 * FIPS186-4 A.2 Generation of canonical generator g.
 *
 * It requires the following values as input:
 *   'evpmd' digest, 'p' prime, 'e' cofactor, gindex and seed.
 * tmp is a passed in temporary BIGNUM.
 * mont is used in a BN_mod_exp_mont() with a modulus of p.
 * Returns a value in g.
 */
static int generate_canonical_g(BN_CTX *ctx, BN_MONT_CTX *mont,
				const EVP_MD *evpmd, BIGNUM *g, BIGNUM *w,
				const BIGNUM *p, const BIGNUM *e,
				int gindex, unsigned char *seed, size_t seedlen)
{
	unsigned char md[EVP_MAX_MD_SIZE];
	EVP_MD_CTX *mctx;
	int counter = 1;
	int ret = 0;
	int mdsize;

	mdsize = EVP_MD_get_size(evpmd);
	if (mdsize <= 0)
		return 0;

	mctx = EVP_MD_CTX_new();
	if (mctx == NULL)
		return 0;

	/*
	 * A.2.3 Step (4) & (5)
	 * A.2.4 Step (6) & (7)
	 * counter = 0; counter += 1
	 */
	for (counter = 1; counter <= 0xFFFF; ++counter) {
		/*
		 * A.2.3 Step (7) & (8) & (9)
		 * A.2.4 Step (9) & (10) & (11)
		 * W = Hash(seed || "ggen" || index || counter)
		 * g = W^e % p
		 */
		static const unsigned char ggen[4] = { 0x67, 0x67, 0x65, 0x6e };

		/* Get last 8 bits of gindex to the first byte of md */
		md[0] = (unsigned char)(gindex & 0xff);
		/* Get second 8 bits of counter to the second byte of md */
		md[1] = (unsigned char)((counter >> 8) & 0xff);
		/* Get last 8 bits of counter to the third byte of md */
		md[2] = (unsigned char)(counter & 0xff);
		/* Compute digest: W = Hash(seed || "ggen" || index || counter) */
		if (!EVP_DigestInit_ex(mctx, evpmd, NULL) ||
		    !EVP_DigestUpdate(mctx, seed, seedlen) ||
		    !EVP_DigestUpdate(mctx, ggen, sizeof(ggen)) ||
		    /* Hash the first three bytes of md, corresponds to 'index || counter' */
		    !EVP_DigestUpdate(mctx, md, 3) ||
		    !EVP_DigestFinal_ex(mctx, md, NULL) ||
		    (BN_bin2bn(md, mdsize, w) == NULL) ||
		    !BN_mod_exp_mont(g, w, e, p, ctx, mont))
			break; /* exit on failure */
		/*
		 * A.2.3 Step (10)
		 * A.2.4 Step (12)
		 * Found a value for g if (g >= 2)
		 */
		if (BN_cmp(g, BN_value_one()) > 0) {
			ret = 1;
			break; /* found g */
		}
	}

	EVP_MD_CTX_free(mctx);

	return ret;
}

/*
 * FIPS 186-4 FFC parameter generation (as defined in Appendix A).
 * The same code is used for validation (when validate_flags != 0)
 *
 * The primes p & q are generated/validated using:
 *   A.1.1.2 Generation of probable primes p & q using approved hash.
 *   A.1.1.3 Validation of generated probable primes
 *
 * Generator 'g' has 2 types in FIPS 186-4:
 *   (1) A.2.1 unverifiable generation of generator g.
 *       A.2.2 Assurance of the validity of unverifiable generator g.
 *   (2) A.2.3 Verifiable Canonical Generation of the generator g.
 *       A.2.4 Validation for Canonical Generation of the generator g.
 *
 * Notes:
 * (1) is only a partial validation of g, The validation of (2) requires
 * the seed and index used during generation as input.
 *
 * params: used to pass in values for generation and validation.
 * params->md: is the digest to use, If this value is NULL, then the digest is
 *   chosen using the value of N.
 * params->flags:
 *  For validation one of:
 *   -FFC_PARAM_FLAG_VALIDATE_PQ
 *   -FFC_PARAM_FLAG_VALIDATE_G
 *   -FFC_PARAM_FLAG_VALIDATE_PQG
 *  For generation of p & q:
 *   - This is skipped if p & q are passed in.
 *   - If the seed is passed in then generation of p & q uses this seed (and if
 *     this fails an error will occur).
 *   - Otherwise the seed is generated, and values of p & q are generated and
 *     the value of seed and counter are optionally returned.
 *  For the generation of g (after the generation of p, q):
 *   - If the seed has been generated or passed in and a valid gindex is passed
 *     in then canonical generation of g is used otherwise unverifiable
 *     generation of g is chosen.
 *  For validation of p & q:
 *   - p, q, and the seed and counter used for generation must be passed in.
 *  For validation of g:
 *   - For a partial validation : p, q and g are required.
 *   - For a canonical validation : the gindex and seed used for generation are
 *     also required.
 * mode: The mode - either FFC_PARAM_MODE_GENERATE or FFC_PARAM_MODE_VERIFY.
 * type: The key type - FFC_PARAM_TYPE_DSA or FFC_PARAM_TYPE_DH.
 * L: is the size of the prime p in bits (e.g 2048)
 * N: is the size of the prime q in bits (e.g 256)
 * res: A returned failure reason (One of FFC_CHECK_XXXX),
 *      or 0 for general failures.
 * cb: A callback (can be NULL) that is called during different phases
 *
 * Returns:
 *   - FFC_PARAM_RET_STATUS_FAILED: if there was an error, or validation failed.
 *   - FFC_PARAM_RET_STATUS_SUCCESS if the generation or validation succeeded.
 *   - FFC_PARAM_RET_STATUS_UNVERIFIABLE_G if the validation of G succeeded,
 *     but G is unverifiable.
 */
static int ossl_ffc_params_FIPS186_4_gen_verify(OSSL_LIB_CTX *libctx,
						FFC_PARAMS *params, int mode,
						int type, size_t L, size_t N,
						int *res, BN_GENCB *cb)
{
	int ok = FFC_PARAM_RET_STATUS_FAILED;
	unsigned char *seed = NULL, *seed_tmp = NULL;
	int mdsize, counter = 0, pcounter = 0, r = 0;
	size_t seedlen = 0;
	BIGNUM *tmp, *pm1, *e, *test;
	BIGNUM *g = NULL, *q = NULL, *p = NULL;
	BN_MONT_CTX *mont = NULL;
	int n = 0, m = 0, qsize;
	int canonical_g = 0, hret = 0;
	BN_CTX *ctx = NULL;
	EVP_MD_CTX *mctx = NULL;
	EVP_MD *md = NULL;
	int verify = (mode == FFC_PARAM_MODE_VERIFY);
	unsigned int flags = verify ? params->flags : 0;
	const char *def_name;

	*res = 0;

	if (params->mdname != NULL) {
		md = EVP_MD_fetch(libctx, params->mdname, params->mdprops);
	} else {
		if (N == 0) {
			if (L >= L_P_2048BITS)
				N = TRANS_BYTES_TO_BITS(SHA256_DIGEST_LENGTH);
			else
				N = TRANS_BYTES_TO_BITS(SHA_DIGEST_LENGTH);
		}

		def_name = default_mdname(N);
		if (def_name == NULL) {
			*res = FFC_CHECK_INVALID_Q_VALUE;
			goto err;
		}
		md = EVP_MD_fetch(libctx, def_name, params->mdprops);
	}

	if (md == NULL)
		goto err;
	mdsize = EVP_MD_get_size(md);
	if (mdsize <= 0)
		goto err;

	if (N == 0)
		N = TRANS_BYTES_TO_BITS((size_t)mdsize);

	qsize = TRANS_BITS_TO_BYTES(N);

	/*
	 * A.1.1.2 Step (1) AND
	 * A.1.1.3 Step (3)
	 * Check that the L,N pair is an acceptable pair.
	 */
	if (L <= N || !ffc_validate_LN(L, N, type, verify)) {
		*res = FFC_CHECK_BAD_LN_PAIR;
		goto err;
	}

	mctx = EVP_MD_CTX_new();
	if (mctx == NULL)
		goto err;

	ctx = BN_CTX_new_ex(libctx);
	if (ctx == NULL)
		goto err;

	BN_CTX_start(ctx);
	g = BN_CTX_get(ctx);
	pm1 = BN_CTX_get(ctx);
	e = BN_CTX_get(ctx);
	test = BN_CTX_get(ctx);
	tmp = BN_CTX_get(ctx);
	if (tmp == NULL)
		goto err;

	seedlen = params->seedlen;
	if (seedlen == 0)
		seedlen = (size_t)mdsize;
	/* If the seed was passed in - use this value as the seed */
	if (params->seed != NULL)
		seed = params->seed;

	if (!verify) {
		/* For generation: p & q must both be NULL or NON-NULL */
		if ((params->p == NULL) != (params->q == NULL)) {
			*res = FFC_CHECK_INVALID_PQ;
			goto err;
		}
	} else {
		/* Validation of p,q requires seed and counter to be valid */
		if ((flags & FFC_PARAM_FLAG_VALIDATE_PQ) != 0) {
			if (seed == NULL || params->pcounter < 0) {
				*res = FFC_CHECK_MISSING_SEED_OR_COUNTER;
				goto err;
			}
		}

		if ((flags & FFC_PARAM_FLAG_VALIDATE_G) != 0) {
			/* validation of g also requires g to be set */
			if (params->g == NULL) {
				*res = FFC_CHECK_INVALID_G;
				goto err;
			}
		}
	}

	/*
	 * If p & q are passed in and
	 *   validate_flags = 0 then skip the generation of PQ.
	 *   validate_flags = VALIDATE_G then also skip the validation of PQ.
	 */
	if (params->p != NULL && ((flags & FFC_PARAM_FLAG_VALIDATE_PQ) == 0)) {
		/* p and q already exists so only generate g */
		p = params->p;
		q = params->q;
		goto g_only;
		/* otherwise to validate p & q */
	}

	/* p & q will be used for generation and validation */
	p = BN_CTX_get(ctx);
	q = BN_CTX_get(ctx);
	if (q == NULL)
		goto err;

	/*
	 * A.1.1.2 Step (2) AND
	 * A.1.1.3 Step (6)
	 * Return invalid if seedlen  < N
	 */
	if ((TRANS_BYTES_TO_BITS(seedlen)) < N) {
		*res = FFC_CHECK_INVALID_SEED_SIZE;
		goto err;
	}

	seed_tmp = OPENSSL_malloc(seedlen);
	if (seed_tmp == NULL)
		goto err;

	if (seed == NULL) {
		/* Validation requires the seed to be supplied */
		if (verify) {
			*res = FFC_CHECK_MISSING_SEED_OR_COUNTER;
			goto err;
		}
		/* if the seed is not supplied then alloc a seed buffer */
		seed = OPENSSL_malloc(seedlen);
		if (seed == NULL)
			goto err;
	}

	/* A.1.1.2 Step (11): max loop count = 4L - 1 */
	counter = 4 * L - 1;
	/* Validation requires the counter to be supplied */
	if (verify) {
		/* A.1.1.3 Step (4) : if (counter > (4L -1)) return INVALID */
		if (params->pcounter > counter) {
			*res = FFC_CHECK_INVALID_COUNTER;
			goto err;
		}
		counter = params->pcounter;
	}

	/*
	 * A.1.1.2 Step (3) AND
	 * A.1.1.3 Step (10)
	 * n = floor(L / hash_outlen) - 1
	 */
	n = (L - 1) / (mdsize << 3);

	/* Calculate 2^(L-1): Used in step A.1.1.2 Step (11.3) */
	if (!BN_lshift(test, BN_value_one(), L - 1))
		goto err;

	for (;;) {
		if (!generate_q_fips186_4(ctx, q, md, qsize, seed, seedlen,
					  seed != params->seed, &m, res, cb))
			goto err;
		/* A.1.1.3 Step (9): Verify that q matches the expected value */
		if (verify && (BN_cmp(q, params->q) != 0)) {
			*res = FFC_CHECK_Q_MISMATCH;
			goto err;
		}

		if (!BN_GENCB_call(cb, GENCB_NEXT, 0))
			goto err;
		if (!BN_GENCB_call(cb, GENCB_RETRY, 0))
			goto err;

		memcpy(seed_tmp, seed, seedlen);
		r = generate_p(ctx, md, counter, n, seed_tmp, seedlen, q, p, L,
			       cb, &pcounter, res);
		if (r > 0)
			break; /* found p */
		if (r < 0)
			goto err;
		/*
		 * A.1.1.3 Step (14):
		 * If we get here we failed to get a p for the given seed. If the
		 * seed is not random then it needs to fail (as it will always fail).
		 */
		if (seed == params->seed) {
			*res = FFC_CHECK_P_NOT_PRIME;
			goto err;
		}
	}
	if (!BN_GENCB_call(cb, GENCB_NEXT, 1))
		goto err;
	/*
	 * Gets here if we found p.
	 * A.1.1.3 Step (14): return error if i != counter OR computed_p != known_p.
	 */
	if (verify && (pcounter != counter || (BN_cmp(p, params->p) != 0)))
		goto err;

	/* If validating p & q only then skip the g validation test */
	if ((flags & FFC_PARAM_FLAG_VALIDATE_PQG) == FFC_PARAM_FLAG_VALIDATE_PQ)
		goto pass;

g_only:
	mont = BN_MONT_CTX_new();
	if (mont == NULL)
		goto err;
	if (!BN_MONT_CTX_set(mont, p, ctx))
		goto err;

	if (((flags & FFC_PARAM_FLAG_VALIDATE_G) != 0) &&
	    !ossl_ffc_params_validate_unverifiable_g(ctx, mont, p, q, params->g,
						     tmp, res))
		goto err;

	/*
	 * A.2.1 Step (1) AND
	 * A.2.3 Step (3) AND
	 * A.2.4 Step (5)
	 * e = (p - 1) / q (i.e- Cofactor 'e' is given by p = q * e + 1)
	 */
	if (!(BN_sub(pm1, p, BN_value_one()) && BN_div(e, NULL, pm1, q, ctx)))
		goto err;

	/* Canonical g requires a seed and index to be set */
	if ((seed != NULL) && (params->gindex != FFC_UNVERIFIABLE_GINDEX)) {
		canonical_g = 1;
		if (!generate_canonical_g(ctx, mont, md, g, tmp, p, e,
					  params->gindex, seed, seedlen)) {
			*res = FFC_CHECK_INVALID_G;
			goto err;
		}
		/* A.2.4 Step (13): Return valid if computed_g == g */
		if (verify && BN_cmp(g, params->g) != 0) {
			*res = FFC_CHECK_G_MISMATCH;
			goto err;
		}
	} else if (!verify) {
		if (!generate_unverifiable_g(ctx, mont, g, tmp, p, e, pm1, &hret))
			goto err;
	}

	if (!BN_GENCB_call(cb, GENCB_RETRY, 1))
		goto err;

	if (!verify) {
		if (p != params->p) {
			BN_free(params->p);
			params->p = BN_dup(p);
		}
		if (q != params->q) {
			BN_free(params->q);
			params->q = BN_dup(q);
		}
		if (g != params->g) {
			BN_free(params->g);
			params->g = BN_dup(g);
		}
		if (params->p == NULL || params->q == NULL || params->g == NULL)
			goto err;

		if (!ossl_ffc_params_set_validate_params(params, seed, seedlen, pcounter))
			goto err;
		params->h = hret;
	}
pass:
	if ((flags & FFC_PARAM_FLAG_VALIDATE_G) != 0 && (canonical_g == 0))
		/* Return for the case where g is partially valid */
		ok = FFC_PARAM_RET_STATUS_UNVERIFIABLE_G;
	else
		ok = FFC_PARAM_RET_STATUS_SUCCESS;
err:
	if (seed != params->seed)
		OPENSSL_free(seed);
	OPENSSL_free(seed_tmp);
	if (ctx != NULL)
		BN_CTX_end(ctx);
	BN_CTX_free(ctx);
	BN_MONT_CTX_free(mont);
	EVP_MD_CTX_free(mctx);
	EVP_MD_free(md);
	return ok;
}

int ossl_ffc_params_FIPS186_4_generate(OSSL_LIB_CTX *libctx, FFC_PARAMS *params,
				       int type, size_t L, size_t N,
				       int *res, BN_GENCB *cb)
{
	return ossl_ffc_params_FIPS186_4_gen_verify(libctx, params,
						    FFC_PARAM_MODE_GENERATE,
						    type, L, N, res, cb);
}

/*
 * Multiply two scaled integers together and rescale the result.
 */
static ossl_inline uint64_t mul2(uint64_t a, uint64_t b)
{
	return a * b / DH_SCALE;
}

/*
 * Calculate the natural logarithm of a 64 bit scaled integer.
 * This is done by calculating a base two logarithm and scaling.
 * The maximum logarithm (base 2) is 64 and this reduces base e, so
 * a 32 bit result should not overflow.  The argument passed must be
 * greater than unity so we don't need to handle negative results.
 */
static uint32_t ilog_e(uint64_t v)
{
	uint32_t i, r = 0;

	/*
	 * Scale down the value into the range 1 .. 2.
	 *
	 * If fractional numbers need to be processed, another loop needs
	 * to go here that checks v < scale and if so multiplies it by 2 and
	 * reduces r by scale.  This also means making r signed.
	 */
	while (v >= (DH_C1_923 << 1)) {
		v >>= 1;
		r += DH_C1_923;
	}
	for (i = (DH_C1_923 >> 1); i != 0; i = (i >> 1)) {
		v = mul2(v, v);
		if (v >= (DH_C1_923 << 1)) {
			v >>= 1;
			r += i;
		}
	}
	r = (r * (uint64_t)DH_C1_923) / DH_LOG_E;

	return r;
}

/*
 * Calculate the cube root of a 64 bit scaled integer.
 * Although the cube root of a 64 bit number does fit into a 32 bit unsigned
 * integer, this is not guaranteed after scaling, so this function has a
 * 64 bit return.  This uses the shifting nth root algorithm with some
 * algebraic simplifications.
 */
static uint64_t icbrt64(uint64_t x)
{
	uint64_t r = 0;
	uint64_t b;
	int s;

	for (s = DH_MAX_EXPONENT; s >= 0; s -= DH_EXPONENT_SHIFT_3) {
		r <<= 1;
		b = DH_EXPONENT_SHIFT_3 * r * (r + 1) + 1;
		if ((x >> s) >= b) {
			x -= b << s;
			r++;
		}
	}

	return r * DH_CBRT_SCALE;
}

uint16_t ossl_ifc_ffc_compute_security_bits(int n)
{
	uint16_t y, cap;
	uint32_t lx;
	uint64_t x;

	/*
	 * Look for common values as listed in standards.
	 * These values are not exactly equal to the results from the formulae in
	 * the standards but are defined to be canonical.
	 */
	switch (n) {
	case DH_STANDARDS_P_2048BIT:      /* SP 800-56B rev 2 Appendix D and FIPS 140-2 IG 7.5 */
		return DH_P_SECURITY_112BITS;
	case DH_STANDARDS_P_3072BIT:      /* SP 800-56B rev 2 Appendix D and FIPS 140-2 IG 7.5 */
		return DH_P_SECURITY_128BITS;
	case DH_STANDARDS_P_4096BIT:      /* SP 800-56B rev 2 Appendix D */
		return DH_P_SECURITY_152BITS;
	case DH_STANDARDS_P_6144BIT:      /* SP 800-56B rev 2 Appendix D */
		return DH_P_SECURITY_176BITS;
	case DH_STANDARDS_P_7680BIT:      /* FIPS 140-2 IG 7.5 */
		return DH_P_SECURITY_192BITS;
	case DH_STANDARDS_P_8192BIT:      /* SP 800-56B rev 2 Appendix D */
		return DH_P_SECURITY_200BITS;
	case DH_STANDARDS_P_15360BIT:     /* FIPS 140-2 IG 7.5 */
		return DH_P_SECURITY_256BITS;
	}

	/*
	 * The first incorrect result (i.e. not accurate or off by one low) occurs
	 * for n = 699668.  The true value here is 1200.  Instead of using this n
	 * as the check threshold, the smallest n such that the correct result is
	 * 1200 is used instead.
	 */
	if (n >= DH_STANDARDS_P_MAX_BIT)
		return DH_P_SECURITY_1200BITS;
	if (n < DH_STANDARDS_P_MIN_BIT)
		return 0;

	/*
	 * To ensure that the output is non-decreasing with respect to n,
	 * a cap needs to be applied to the two values where the function over
	 * estimates the strength (according to the above fast path).
	 */
	if (n <= DH_STANDARDS_P_7680BIT)
		cap = DH_P_SECURITY_192BITS;
	else if (n <= DH_STANDARDS_P_15360BIT)
		cap = DH_P_SECURITY_256BITS;
	else
		cap = DH_P_SECURITY_1200BITS;

	x = n * DH_LOG_2;
	lx = ilog_e(x);
	y = (uint16_t)((mul2(DH_C1_923, icbrt64(mul2(mul2(x, lx), lx))) - DH_C4_690) /
		       DH_LOG_2);
	y = (y + DH_CAI_NUM4) & ~DH_CAI_NUM7;
	if (y > cap)
		y = cap;

	return y;
}

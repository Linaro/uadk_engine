// SPDX-License-Identifier: Apache-2.0
/*
 * Copyright 2023-2024 Huawei Technologies Co.,Ltd. All rights reserved.
 * Copyright 2023-2024 Linaro ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
#include <openssl/core_names.h>
#include <openssl/dh.h>
#include <openssl/kdf.h>
#include <openssl/proverr.h>
#include <uadk/wd_dh.h>
#include <uadk/wd_sched.h>
#include "uadk.h"
#include "uadk_async.h"
#include "uadk_prov.h"
#include "uadk_prov_ffc.h"
#include "uadk_prov_pkey.h"

#define DH768BITS			768
#define DH1024BITS			1024
#define DH1536BITS			1536
#define DH2048BITS			2048
#define DH3072BITS			3072
#define DH4096BITS			4096
#define UADK_DH_MAX_MODULE_BIT		4096
#define DH_GENERATOR_2			2
#define CHAR_BIT_SIZE			3
#define DH_PARAMS_CNT			3
#define CTX_MODE_NUM			2
#define UN_SET				0
#define IS_SET				1
#define CTX_ASYNC			1
#define CTX_SYNC			0
#define CTX_NUM				2
#define UADK_DO_SOFT			(-0xE0)
#define UADK_P_INIT_SUCCESS		0
#define ENV_ENABLED			1
#define KEY_GEN_BY_PROV			1
#define KEY_GEN_BY_USR			0
#define RAND_MAX_CNT			1000
#define LEN_ZERO			0
#define DH_MAX_PARAM_LEN		80
#define IGNORE_Q			1
#define USE_PAD				1
#define KDF_PARAM_NUM			5

UADK_PKEY_KEYMGMT_DESCR(dh, DH);
UADK_PKEY_KEYEXCH_DESCR(dh, DH);

static pthread_mutex_t dh_mutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_mutex_t dh_default_mutex = PTHREAD_MUTEX_INITIALIZER;
static UADK_PKEY_KEYEXCH get_default_dh_keyexch(void)
{
	static UADK_PKEY_KEYEXCH s_keyexch;
	static int initilazed;

	pthread_mutex_lock(&dh_default_mutex);
	if (!initilazed) {
		UADK_PKEY_KEYEXCH *keyexch =
			(UADK_PKEY_KEYEXCH *)EVP_KEYEXCH_fetch(NULL, "dh", "provider=default");
		if (keyexch) {
			s_keyexch = *keyexch;
			EVP_KEYEXCH_free((EVP_KEYEXCH *)keyexch);
			initilazed = 1;
		} else {
			fprintf(stderr, "failed to EVP_KEYEXCH_fetch default dh provider\n");
		}
	}
	pthread_mutex_unlock(&dh_default_mutex);

	return s_keyexch;
}

struct dh_st {
	/*
	 * This first argument is used to pick up errors when a DH is passed
	 * instead of a EVP_PKEY
	 */
	int pad;
	int version;
	FFC_PARAMS params;
	/* max generated private key length (can be less than len(q)) */
	int32_t length;
	BIGNUM *pub_key;  /* g^x % p */
	BIGNUM *priv_key; /* x */
	int flags;
	BN_MONT_CTX *method_mont_p;
	int references;
#ifndef FIPS_MODULE
	CRYPTO_EX_DATA ex_data;
	ENGINE *engine;
#endif
	OSSL_LIB_CTX * libctx;
	const DH_METHOD *meth;
	void *lock;

	/* Provider data */
	/* If any key material changes, increment this */
	size_t dirty_cnt;
}; /* DH */

struct dh_method {
	char *name;
	/* Methods here */
	int (*generate_key)(DH *dh);
	int (*compute_key)(unsigned char *key, const BIGNUM *pub_key, DH *dh);

	/* Can be null */
	int (*bn_mod_exp)(const DH *dh, BIGNUM *r, const BIGNUM *a,
			  const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,
			  BN_MONT_CTX *m_ctx);
	int (*init)(DH *dh);
	int (*finish)(DH *dh);
	int flags;
	char *app_data;
	/* If this is non-NULL, it will be used to generate parameters */
	int (*generate_params)(DH *dh, int prime_len, int generator,
			       BN_GENCB *cb);
};

struct uadk_dh_sess {
	handle_t sess;
	struct wd_dh_sess_setup setup;
	struct wd_dh_req req;
	DH *alg;
	__u16 key_size;
	/*
	 * key_flag: 0 - key is defined by user
	 * 1 - key is generated by provider
	 */
	int key_flag;
};

struct dh_res {
	int pid;
} g_dh_prov;

/*
 * This type is only really used to handle some legacy related functionality.
 * If you need to use other KDF's (such as SSKDF) just use PROV_DH_KDF_NONE
 * here and then create and run a KDF after the key is derived.
 * Note that X942 has 2 variants of key derivation:
 *   (1) DH_KDF_X9_42_ASN1 - which contains an ANS1 encoded object that has
 *   the counter embedded in it.
 *   (2) DH_KDF_X941_CONCAT - which is the same as ECDH_X963_KDF (which can be
 *       done by creating a "X963KDF".
 */
enum kdf_type {
	PROV_DH_KDF_NONE = 0,
	PROV_DH_KDF_X9_42_ASN1
};

typedef struct {
	OSSL_LIB_CTX *libctx;

	FFC_PARAMS *ffc_params;
	int selection;
	/* All these parameters are used for parameter generation only */
	/* If there is a group name then the remaining parameters are not needed */
	int group_nid;
	size_t pbits;
	size_t qbits;
	unsigned char *seed; /* optional FIPS186-4 param for testing */
	size_t seedlen;
	int gindex; /* optional  FIPS186-4 generator index (ignored if -1) */
	int gen_type; /* see dhtype2id */
	int generator; /* Used by DH_PARAMGEN_TYPE_GENERATOR in non fips mode only */
	int pcounter;
	int hindex;
	int priv_len;

	char *mdname;
	char *mdprops;
	OSSL_CALLBACK *cb;
	void *cbarg;
	int dh_type;
} PROV_DH_KEYMGMT_CTX;

/*
 * What's passed as an actual key is defined by the KEYMGMT interface.
 * We happen to know that our KEYMGMT simply passes DH structures, so
 * we use that here too.
 */
typedef struct {
	OSSL_LIB_CTX *libctx;
	DH *dh;
	DH *dhpeer;
	unsigned int pad : 1;

	/* DH KDF */
	/* KDF (if any) to use for DH */
	enum kdf_type kdf_type;
	/* Message digest to use for key derivation */
	EVP_MD *kdf_md;
	/* User key material */
	unsigned char *kdf_ukm;
	size_t kdf_ukmlen;
	/* KDF output length */
	size_t kdf_outlen;
	char *kdf_cekalg;
} PROV_DH_KEYEXCH_CTX;

static const char *uadk_keymgmt_dh_query_operation_name(int operation_id)
{
	if (get_default_dh_keymgmt().query_operation_name == NULL)
		return NULL;

	return get_default_dh_keymgmt().query_operation_name(operation_id);
}

static void *uadk_keymgmt_dh_new(void *provctx)
{
	if (get_default_dh_keymgmt().new_fun == NULL)
		return NULL;

	return get_default_dh_keymgmt().new_fun(provctx);
}

static void uadk_keymgmt_dh_free(void *keydata)
{
	if (get_default_dh_keymgmt().free == NULL)
		return;

	get_default_dh_keymgmt().free(keydata);
}

static int uadk_keymgmt_dh_has(const void *keydata, int selection)
{
	if (get_default_dh_keymgmt().has == NULL)
		return UADK_P_FAIL;

	return get_default_dh_keymgmt().has(keydata, selection);
}

static int uadk_keymgmt_dh_match(const void *keydata1, const void *keydata2, int selection)
{
	if (get_default_dh_keymgmt().match == NULL)
		return UADK_P_FAIL;

	return get_default_dh_keymgmt().match(keydata1, keydata2, selection);
}

static int uadk_keymgmt_dh_import(void *keydata, int selection, const OSSL_PARAM params[])
{
	if (get_default_dh_keymgmt().import == NULL)
		return UADK_P_FAIL;

	return get_default_dh_keymgmt().import(keydata, selection, params);
}

static int uadk_keymgmt_dh_export(void *keydata, int selection, OSSL_CALLBACK *cb, void *cb_params)
{
	if (get_default_dh_keymgmt().export_fun == NULL)
		return UADK_P_FAIL;

	return get_default_dh_keymgmt().export_fun(keydata, selection, cb, cb_params);
}

static const OSSL_PARAM *uadk_keymgmt_dh_import_types(int selection)
{
	if (get_default_dh_keymgmt().import_types == NULL)
		return NULL;

	return get_default_dh_keymgmt().import_types(selection);
}

static const OSSL_PARAM *uadk_keymgmt_dh_export_types(int selection)
{
	if (get_default_dh_keymgmt().export_types == NULL)
		return NULL;

	return get_default_dh_keymgmt().export_types(selection);
}

static ossl_inline int uadk_keymgmt_dh_get_params(void *key, OSSL_PARAM params[])
{
	if (get_default_dh_keymgmt().get_params == NULL)
		return UADK_P_FAIL;

	return get_default_dh_keymgmt().get_params(key, params);
}

static const OSSL_PARAM *uadk_keymgmt_dh_gettable_params(void *provctx)
{
	if (get_default_dh_keymgmt().gettable_params == NULL)
		return NULL;

	return get_default_dh_keymgmt().gettable_params(provctx);
}

static const OSSL_PARAM *uadk_keymgmt_dh_settable_params(void *provctx)
{
	if (get_default_dh_keymgmt().settable_params == NULL)
		return NULL;

	return get_default_dh_keymgmt().settable_params(provctx);
}

static int uadk_keymgmt_dh_set_params(void *key, const OSSL_PARAM params[])
{
	if (get_default_dh_keymgmt().set_params == NULL)
		return UADK_P_FAIL;

	return get_default_dh_keymgmt().set_params(key, params);
}

static int uadk_keymgmt_dh_validate(const void *keydata, int selection, int checktype)
{
	if (get_default_dh_keymgmt().validate == NULL)
		return UADK_P_FAIL;

	return get_default_dh_keymgmt().validate(keydata, selection, checktype);
}

static void *uadk_keymgmt_dh_gen_init(void *provctx, int selection,
				      const OSSL_PARAM params[])
{
	if (get_default_dh_keymgmt().gen_init == NULL)
		return NULL;

	return get_default_dh_keymgmt().gen_init(provctx, selection, params);
}

static int uadk_keymgmt_dh_gen_set_template(void *genctx, void *templ)
{
	if (get_default_dh_keymgmt().gen_set_template == NULL)
		return UADK_P_FAIL;

	return get_default_dh_keymgmt().gen_set_template(genctx, templ);
}

static const OSSL_PARAM *uadk_keymgmt_dh_gen_settable_params(ossl_unused void *genctx,
						ossl_unused void *provctx)
{
	if (get_default_dh_keymgmt().gen_settable_params == NULL)
		return NULL;

	return get_default_dh_keymgmt().gen_settable_params(genctx, provctx);
}

static int uadk_keymgmt_dh_gen_set_params(void *genctx,
					  const OSSL_PARAM params[])
{
	if (get_default_dh_keymgmt().gen_set_params == NULL)
		return UADK_P_FAIL;

	return get_default_dh_keymgmt().gen_set_params(genctx, params);
}

static void uadk_keymgmt_dh_gen_cleanup(void *genctx)
{
	if (get_default_dh_keymgmt().gen_cleanup == NULL)
		return;

	get_default_dh_keymgmt().gen_cleanup(genctx);
}

static void *uadk_keymgmt_dh_load(const void *reference, size_t reference_sz)
{
	if (get_default_dh_keymgmt().load == NULL)
		return NULL;

	return get_default_dh_keymgmt().load(reference, reference_sz);
}

static void *uadk_keymgmt_dh_dup(const void *keydata_from, int selection)
{
	if (get_default_dh_keymgmt().dup == NULL)
		return NULL;

	return get_default_dh_keymgmt().dup(keydata_from, selection);
}

static int uadk_DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key)
{
	if (dh == NULL) {
		fprintf(stderr, "invalid: dh is NULL\n");
		return UADK_P_FAIL;
	}

	if (pub_key != NULL) {
		BN_clear_free(dh->pub_key);
		dh->pub_key = pub_key;
	}

	if (priv_key != NULL) {
		BN_clear_free(dh->priv_key);
		dh->priv_key = priv_key;
	}

	dh->dirty_cnt++;

	return UADK_P_SUCCESS;
}

static FFC_PARAMS *ossl_dh_get0_params(DH *dh)
{
	if (dh == NULL)
		return NULL;

	return &dh->params;
}

static const BIGNUM *uadk_DH_get0_p(const DH *dh)
{
	if (dh == NULL)
		return NULL;

	return dh->params.p;
}

static long uadk_DH_get_length(const DH *dh)
{
	if (dh == NULL)
		return LEN_ZERO;

	return dh->length;
}

static void uadk_DH_get0_pqg(const DH *dh, const BIGNUM **p,
			     const BIGNUM **q, const BIGNUM **g)
{
	ossl_ffc_params_get0_pqg(&dh->params, p, q, g);
}

static const BIGNUM *uadk_DH_get0_priv_key(const DH *dh)
{
	if (dh == NULL)
		return NULL;

	return dh->priv_key;
}

static const BIGNUM *uadk_DH_get0_pub_key(const DH *dh)
{
	if (dh == NULL)
		return NULL;

	return dh->pub_key;
}

static int uadk_DH_bits(const DH *dh)
{
	int bits = 0;

	if (dh == NULL)
		return bits;

	if (dh->params.p != NULL)
		bits = BN_num_bits(dh->params.p);

	return bits;
}

static void uadk_DH_clear_flags(DH *dh, int flags)
{
	dh->flags &= ~flags;
}

static void uadk_DH_set_flags(DH *dh, int flags)
{
	dh->flags |= flags;
}

static int uadk_dh_gen_prikey_undef(const DH *dh, BIGNUM *new_prikey)
{
	int bits;

	bits = uadk_DH_get_length(dh) ?
			uadk_DH_get_length(dh) : BN_num_bits(uadk_DH_get0_p(dh)) - 1;
	if (!BN_priv_rand(new_prikey, bits, BN_RAND_TOP_ONE, BN_RAND_BOTTOM_ANY)) {
		fprintf(stderr, "failed to BN_priv_rand\n");
		return UADK_P_FAIL;
	}
	return UADK_P_SUCCESS;
}

static int dh_gen_rand_prikey(const DH *dh, BIGNUM *new_prikey)
{
	int qbits, max_strength, n, cnt = 0;
	BIGNUM *m, *two_powN = NULL;

	n = dh->length;
	if (DH_get_nid(dh) == NID_undef || dh->params.q == NULL)
		return uadk_dh_gen_prikey_undef(dh, new_prikey);

	max_strength = ossl_ifc_ffc_compute_security_bits(BN_num_bits(dh->params.p));
	/* Deal with the edge cases where the value of n and/or s is not set */
	if (dh->length > BN_num_bits(dh->params.q) || max_strength == 0)
		return UADK_P_FAIL;

	if (n == 0)
		n = dh->params.keylength ? dh->params.keylength : (max_strength << 1);

	qbits = BN_num_bits(dh->params.q);
	/* Step (2) : check range of n */
	if (n < (max_strength << 1) || n > qbits) {
		fprintf(stderr, "n is invalid!\n");
		return UADK_P_FAIL;
	}

	two_powN = BN_new();
	/* 2^n */
	if (two_powN == NULL || !BN_lshift(two_powN, BN_value_one(), n)) {
		fprintf(stderr, "failed to BN_new or two_powN is zero\n");
		goto err;
	}

	/* Step (5) : M = min(2 ^ n, q) */
	m = (BN_cmp(two_powN, dh->params.q) > 0) ? dh->params.q : two_powN;

	do {
		if (!BN_priv_rand_range_ex(new_prikey, two_powN, 0, NULL)
			|| !BN_add_word(new_prikey, 1)) {
			fprintf(stderr, "failed to BN_priv_rand_range_ex\n");
			goto err;
		}
		/* Step (6) : loop if c > M - 2 (i.e. c + 1 >= M) */
		if (BN_cmp(new_prikey, m) < 0)
			break;

		if (cnt++ > RAND_MAX_CNT) {
			fprintf(stderr, "failed to get appropriate prikey, timeout\n");
			goto err;
		}
	} while (1);

	BN_free(two_powN);
	return UADK_P_SUCCESS;
err:
	BN_free(two_powN);
	return UADK_P_FAIL;
}

static int uadk_prov_dh_prepare_prikey(struct uadk_dh_sess *dh_sess, const DH *dh, BIGNUM **prikey)
{
	*prikey = (BIGNUM *)uadk_DH_get0_priv_key(dh);

	if (*prikey == NULL) {
		*prikey = BN_secure_new();
		if (*prikey == NULL) {
			fprintf(stderr, "failed to do BN_secure_new\n");
			return UADK_P_FAIL;
		}

		if (dh_gen_rand_prikey(dh, *prikey) == UADK_P_FAIL) {
			fprintf(stderr, "failed to generate new private key\n");
			goto free_prikey;
		}

		dh_sess->key_flag = KEY_GEN_BY_PROV;
	} else {
		dh_sess->key_flag = KEY_GEN_BY_USR;
	}

	return UADK_P_SUCCESS;

free_prikey:
	/* Free the prikey generated by uadk provider */
	BN_free(*prikey);
	*prikey = NULL;

	return UADK_P_FAIL;
}

static void uadk_prov_dh_free_prikey(struct uadk_dh_sess *dh_sess, BIGNUM *prikey)
{
	if (dh_sess == NULL)
		return;

	/* User generated key will be freed by user, not uadk provider */
	if (prikey && dh_sess->key_flag == KEY_GEN_BY_PROV)
		BN_free(prikey);
}

static void uadk_prov_dh_cb(void *req_t)
{
	struct wd_dh_req *req_new = (struct wd_dh_req *)req_t;
	struct uadk_e_cb_info *cb_param;
	struct wd_dh_req *req_origin;
	struct async_op *op;

	if (req_new == NULL)
		return;

	cb_param = req_new->cb_param;
	if (cb_param == NULL)
		return;

	req_origin = cb_param->priv;
	if (req_origin == NULL)
		return;

	req_origin->status = req_new->status;
	if (req_origin->status == 0)
		req_origin->pri_bytes = req_new->pri_bytes;

	op = cb_param->op;
	if (op && op->job && !op->done) {
		op->done = 1;
		async_free_poll_task(op->idx, 1);
		(void) async_wake_job(op->job);
	}
}

static int uadk_prov_dh_poll(void *ctx)
{
	__u64 rx_cnt = 0;
	__u32 recv = 0;
	/* Poll one packet currently */
	int expt = 1;
	int ret;

	do {
		ret = wd_dh_poll(expt, &recv);
		if (ret < 0 || recv == expt)
			return ret;
		rx_cnt++;
	} while (rx_cnt < PROV_ENV_RECV_MAX_CNT);

	fprintf(stderr, "failed to poll msg: timeout!\n");

	return -ETIMEDOUT;
}

static void uadk_prov_dh_mutex_infork(void)
{
	/* Release the replication lock of the child process */
	pthread_mutex_unlock(&dh_mutex);
}

static int uadk_prov_dh_init(void)
{
	char alg_name[] = "dh";
	int ret;

	pthread_atfork(NULL, NULL, uadk_prov_dh_mutex_infork);
	pthread_mutex_lock(&dh_mutex);
	if (g_dh_prov.pid != getpid()) {
		ret = wd_dh_init2(alg_name, SCHED_POLICY_RR, TASK_HW);
		if (unlikely(ret)) {
			pthread_mutex_unlock(&dh_mutex);
			return ret;
		}
		g_dh_prov.pid = getpid();
		async_register_poll_fn(ASYNC_TASK_DH, uadk_prov_dh_poll);
	}
	pthread_mutex_unlock(&dh_mutex);

	return UADK_P_INIT_SUCCESS;
}

/* Uninit only when the process exits, not uninit when thread exits */
void uadk_prov_dh_uninit(void)
{
	pthread_mutex_lock(&dh_mutex);
	if (g_dh_prov.pid == getpid()) {
		wd_dh_uninit2();
		g_dh_prov.pid = 0;
	}
	pthread_mutex_unlock(&dh_mutex);
}

static struct uadk_dh_sess *uadk_prov_dh_new_session(DH *dh, __u16 bits, bool is_g2)
{
	struct uadk_dh_sess *dh_sess = OPENSSL_zalloc(sizeof(struct uadk_dh_sess));
	__u16 key_size = bits >> CHAR_BIT_SIZE;
	struct sched_params params = {0};

	if (dh_sess == NULL) {
		fprintf(stderr, "failed to alloc dh session\n");
		return NULL;
	}

	dh_sess->alg = dh;
	dh_sess->key_size = key_size;
	dh_sess->setup.key_bits = bits;
	dh_sess->setup.is_g2 = is_g2;
	/* Use the default numa parameters */
	params.numa_id = -1;
	dh_sess->setup.sched_param = &params;
	dh_sess->sess = wd_dh_alloc_sess(&dh_sess->setup);
	if (dh_sess->sess == (handle_t)0) {
		fprintf(stderr, "failed to init dh sess\n");
		OPENSSL_free(dh_sess);
		return NULL;
	}

	return dh_sess;
}

static void uadk_prov_dh_free_session(struct uadk_dh_sess *dh_sess)
{
	if (dh_sess == NULL)
		return;

	if (dh_sess->sess)
		wd_dh_free_sess(dh_sess->sess);

	OPENSSL_free(dh_sess);
}

static int check_dh_bit_useful(const __u16 bits)
{
	/*
	 * Check whether bits exceeds the limit.
	 * The max module bits of openssl soft alg is
	 * OPENSSL_DH_MAX_MODULUS_BITS, 10000 bits.
	 * OpenSSL speed tool supports 2048/3072/4096/6144/8192 bits.
	 * UADK supports 768/1024/1536/2048/3072/4096 bits.
	 * UADK-provider will be consistent with UADK.
	 */
	switch (bits) {
	case DH768BITS:
	case DH1024BITS:
	case DH1536BITS:
	case DH2048BITS:
	case DH3072BITS:
	case DH4096BITS:
		return UADK_P_SUCCESS;
	default:
		break;
	}

	return UADK_P_FAIL;
}

static int uadk_prov_dh_prepare_data(const BIGNUM *g, DH *dh, struct uadk_dh_sess **dh_sess,
				     BIGNUM **prikey)
{
	bool is_g2 = BN_is_word(g, DH_GENERATOR_2);
	__u16 bits;
	int ret;

	/*
	 * The max module bits of DH is
	 * OPENSSL_DH_MAX_MODULUS_BITS, 10000 bits.
	 */
	bits = (__u16)uadk_DH_bits(dh);
	if (bits == 0) {
		fprintf(stderr, "invalid dh bits %u\n", bits);
		return UADK_P_FAIL;
	}

	ret = check_dh_bit_useful(bits);
	if (ret == UADK_P_FAIL) {
		fprintf(stderr, "invalid: dh%u is not supported by uadk provider\n", bits);
		return UADK_DO_SOFT;
	}

	*dh_sess = uadk_prov_dh_new_session(dh, bits, is_g2);
	if (*dh_sess == NULL) {
		fprintf(stderr, "failed to get session\n");
		return UADK_P_FAIL;
	}

	ret = uadk_prov_dh_prepare_prikey(*dh_sess, dh, prikey);
	if (ret == UADK_P_FAIL) {
		fprintf(stderr, "failed to get private key\n");
		uadk_prov_dh_free_session(*dh_sess);
	}

	return ret;
}

static void uadk_prov_dh_free_prepare_data(struct uadk_dh_sess *dh_sess, BIGNUM *prikey)
{
	uadk_prov_dh_free_prikey(dh_sess, prikey);
	uadk_prov_dh_free_session(dh_sess);
}

static int dh_set_g(const BIGNUM *g, const __u16 key_size,
		    unsigned char *g_bin, struct uadk_dh_sess *dh_sess)
{
	struct wd_dtb g_dtb = {0};
	__u32 gbytes;
	int ret;

	gbytes = BN_bn2bin(g, g_bin);
	g_dtb.data = (char *)g_bin;
	g_dtb.bsize = key_size;
	g_dtb.dsize = gbytes;

	ret = wd_dh_set_g(dh_sess->sess, &g_dtb);
	if (ret) {
		fprintf(stderr, "failed to set dh g\n");
		return UADK_P_FAIL;
	}

	return UADK_P_SUCCESS;
}

static int uadk_prov_dh_get_pubkey(struct uadk_dh_sess *dh_sess, BIGNUM **pubkey)
{
	const unsigned char *pubkey_str;

	pubkey_str = (const unsigned char *)dh_sess->req.pri;
	if (pubkey_str == NULL) {
		fprintf(stderr, "dh_sess->req.pri is NULL\n");
		return UADK_P_FAIL;
	}

	*pubkey = BN_bin2bn(pubkey_str, dh_sess->req.pri_bytes, *pubkey);
	if (*pubkey == NULL) {
		fprintf(stderr, "failed to trans pubkey outs\n");
		return UADK_P_FAIL;
	}

	return UADK_P_SUCCESS;
}

static int uadk_prov_dh_fill_genkey_req(const BIGNUM *g, const BIGNUM *p, const BIGNUM *prikey,
					struct uadk_dh_sess *dh_sess)
{
	unsigned char *g_bin, *x_bin, *p_bin, *pri_bin;
	__u16 key_size = dh_sess->key_size;

	g_bin = OPENSSL_zalloc(key_size);
	if (g_bin == NULL) {
		fprintf(stderr, "failed to alloc g_bin\n");
		return UADK_P_FAIL;
	}

	/* x is private key, x and p will be treated together in uadk */
	x_bin = OPENSSL_zalloc(key_size * DH_PARAMS_CNT);
	if (x_bin == NULL) {
		fprintf(stderr, "failed to alloc x_bin\n");
		goto free_g;
	}
	p_bin = x_bin + key_size;
	pri_bin = p_bin + key_size;

	/* Construct data block of g */
	if (dh_set_g(g, key_size, g_bin, dh_sess) == UADK_P_FAIL)
		goto free_x_p_pri;

	dh_sess->req.xbytes = BN_bn2bin(prikey, x_bin);
	dh_sess->req.pbytes = BN_bn2bin(p, p_bin);
	dh_sess->req.x_p = (void *)x_bin;
	dh_sess->req.pri = pri_bin;
	dh_sess->req.pri_bytes = key_size;
	dh_sess->req.op_type = WD_DH_PHASE1;

	/* Free binary g right away, free other parameters later */
	OPENSSL_free(g_bin);

	return UADK_P_SUCCESS;

free_x_p_pri:
	OPENSSL_free(x_bin);
free_g:
	OPENSSL_free(g_bin);

	return UADK_P_FAIL;
}

static void uadk_prov_dh_free_genkey_req(struct uadk_dh_sess *dh_sess)
{
	if (dh_sess == NULL)
		return;

	/* Free x_bin, p_bin and pri_bin */
	if (dh_sess->req.x_p)
		OPENSSL_free(dh_sess->req.x_p);
}

static int uadk_prov_dh_do_crypto(struct uadk_dh_sess *dh_sess)
{
	struct uadk_e_cb_info cb_param;
	struct async_op op;
	int idx, ret, cnt;

	ret = async_setup_async_event_notification(&op);
	if (ret == 0) {
		printf("failed to setup async event notification.\n");
		return UADK_P_FAIL;
	}

	if (op.job == NULL) {
		ret = wd_do_dh_sync(dh_sess->sess, &dh_sess->req);
		if (ret)
			return UADK_P_FAIL;
	} else {
		cb_param.op = &op;
		cb_param.priv = &dh_sess->req;
		dh_sess->req.cb = uadk_prov_dh_cb;
		dh_sess->req.cb_param = &cb_param;
		dh_sess->req.status = POLL_ERROR;
		ret = async_get_free_task(&idx);
		if (!ret)
			goto err;

		op.idx = idx;
		cnt = 0;
		do {
			ret = wd_do_dh_async(dh_sess->sess, &dh_sess->req);
			if (ret < 0 && ret != -EBUSY) {
				fprintf(stderr, "failed to do dh async\n");
				goto free_poll_task;
			}

			if (unlikely(++cnt > PROV_SEND_MAX_CNT)) {
				fprintf(stderr, "do dh async operation timeout\n");
				goto free_poll_task;
			}
		} while (ret == -EBUSY);

		ret = async_pause_job(dh_sess, &op, ASYNC_TASK_DH);
		if (!ret)
			goto err;

		ret = dh_sess->req.status;
		if (ret)
			goto err;
	}

	return UADK_P_SUCCESS;

free_poll_task:
	async_free_poll_task(idx, 0);
err:
	(void)async_clear_async_event_notification();
	return UADK_P_FAIL;
}

static int uadk_prov_dh_set_pkey(DH *dh, BIGNUM *pubkey, BIGNUM *prikey)
{
	const BIGNUM *old_priv = uadk_DH_get0_priv_key(dh);
	const BIGNUM *old_pub = uadk_DH_get0_pub_key(dh);
	int ret = UADK_P_SUCCESS;

	if (old_pub != pubkey && old_priv != prikey)
		ret = uadk_DH_set0_key(dh, pubkey, prikey);
	else if (old_pub != pubkey)
		ret = uadk_DH_set0_key(dh, pubkey, NULL);
	else if (old_priv != prikey)
		ret = uadk_DH_set0_key(dh, NULL, prikey);

	return ret;
}

static int uadk_prov_dh_generate_key(DH *dh)
{
	struct uadk_dh_sess *dh_sess = NULL;
	const BIGNUM *p = NULL;
	const BIGNUM *g = NULL;
	BIGNUM *prikey = NULL;
	BIGNUM *pubkey = NULL;
	int ret;

	if (dh == NULL) {
		fprintf(stderr, "invalid: dh is NULL\n");
		return UADK_P_FAIL;
	}

	ret = uadk_prov_dh_init();
	if (ret) {
		fprintf(stderr, "failed to init dh\n");
		return UADK_DO_SOFT;
	}

	uadk_DH_get0_pqg(dh, &p, NULL, &g);
	if (p == NULL || g == NULL) {
		fprintf(stderr, "invalid: p or g is NULL\n");
		return UADK_P_FAIL;
	}

	/* Get session and prepare private key */
	ret = uadk_prov_dh_prepare_data(g, dh, &dh_sess, &prikey);
	if (ret != UADK_P_SUCCESS) {
		fprintf(stderr, "failed to prepare dh data\n");
		return ret;
	}

	ret = uadk_prov_dh_fill_genkey_req(g, p, prikey, dh_sess);
	if (ret == UADK_P_FAIL) {
		fprintf(stderr, "failed to fill req\n");
		goto free_data;
	}

	ret = uadk_prov_dh_do_crypto(dh_sess);
	if (ret != UADK_P_SUCCESS) {
		fprintf(stderr, "failed to generate DH key\n");
		ret = UADK_DO_SOFT;
		goto free_req;
	}

	ret = uadk_prov_dh_get_pubkey(dh_sess, &pubkey);
	if (ret == UADK_P_FAIL) {
		fprintf(stderr, "failed to get public key\n");
		goto free_req;
	}

	ret = uadk_prov_dh_set_pkey(dh, pubkey, prikey);
	if (ret == UADK_P_FAIL)
		fprintf(stderr, "failed to set dh pkey\n");

	uadk_prov_dh_free_genkey_req(dh_sess);
	uadk_prov_dh_free_session(dh_sess);

	return ret;

free_req:
	uadk_prov_dh_free_genkey_req(dh_sess);
free_data:
	uadk_prov_dh_free_prepare_data(dh_sess, prikey);

	return ret;
}

static int dh_gencb(int p, int n, BN_GENCB *cb)
{
	OSSL_PARAM params[] = { OSSL_PARAM_END, OSSL_PARAM_END, OSSL_PARAM_END };
	PROV_DH_KEYMGMT_CTX *gctx = BN_GENCB_get_arg(cb);

	params[0] = OSSL_PARAM_construct_int(OSSL_GEN_PARAM_POTENTIAL, &p);
	params[1] = OSSL_PARAM_construct_int(OSSL_GEN_PARAM_ITERATION, &n);

	return gctx->cb(params, gctx->cbarg);
}

static int ossl_dh_get_named_group_uid_from_size(int pbits)
{
	int nid;

	/*
	 * Just choose an approved safe prime group.
	 * The alternative to this is to generate FIPS186-4 domain parameters i.e.
	 * return dh_generate_ffc_parameters(ret, prime_len, 0, NULL, cb);
	 * As the FIPS186-4 generated params are for backwards compatibility,
	 * the safe prime group should be used as the default.
	 */
	switch (pbits) {
	case DH2048BITS:
		nid = NID_ffdhe2048;
		break;
	case DH3072BITS:
		nid = NID_ffdhe3072;
		break;
	case DH4096BITS:
		nid = NID_ffdhe4096;
		break;
	/*
	 * Retain the commonly supported part. The different specifications are
	 * listed in the unsupported prime_len scope:
	 * 'pbits' 6144 and 8192 are supported by OpenSSL but not supported by uadk,
	 * 'pbits' 768/1024/1536 are not supported by OpenSSL.
	 *
	 */
	default:
		return NID_undef;
	}

	return nid;
}

static int ossl_dh_generate_ffc_parameters(DH *dh, int type, int pbits, int qbits,
					BN_GENCB *cb)
{
	int ret, res;

	if (type == DH_PARAMGEN_TYPE_FIPS_186_2)
		ret = ossl_ffc_params_FIPS186_2_generate(dh->libctx, &dh->params,
						FFC_PARAM_TYPE_DH, pbits, qbits, &res, cb);
	else
		ret = ossl_ffc_params_FIPS186_4_generate(dh->libctx, &dh->params,
						FFC_PARAM_TYPE_DH, pbits, qbits, &res, cb);
	if (ret > 0)
		dh->dirty_cnt++;

	return ret;
}

static DH *ossl_dh_new_ex(OSSL_LIB_CTX *libctx)
{
	DH *dh = OPENSSL_zalloc(sizeof(*dh));

	if (dh == NULL) {
		fprintf(stderr, "failed to alloc dh\n");
		return NULL;
	}

	dh->references = 1;
	dh->lock = CRYPTO_THREAD_lock_new();
	if (dh->lock == NULL) {
		fprintf(stderr, "failed to new dh thread lock\n");
		OPENSSL_free(dh);
		return NULL;
	}

	dh->libctx = libctx;

	return dh;
}

static void ossl_dh_free_ex(DH *dh)
{
	if (dh) {
		CRYPTO_THREAD_lock_free(dh->lock);
		OPENSSL_free(dh);
	}
}

static DH *uadk_prov_dh_gen_params_with_group(PROV_DH_KEYMGMT_CTX *gctx, FFC_PARAMS **ffc)
{
	const DH_NAMED_GROUP *group = NULL;
	DH *dh = NULL;

	/* Select a named group if there is not one already */
	if (gctx->group_nid == NID_undef) {
		gctx->group_nid = ossl_dh_get_named_group_uid_from_size(gctx->pbits);
		if (gctx->group_nid == NID_undef) {
			fprintf(stderr, "failed to get named group uid from size\n");
			return NULL;
		}
	}

	group = ossl_ffc_uid_to_dh_named_group(gctx->group_nid);
	if (group) {
		dh = ossl_dh_new_ex(gctx->libctx);
		if (dh == NULL) {
			fprintf(stderr, "failed to get dh from libctx\n");
			return NULL;
		}
		dh->meth = DH_get_default_method();
		ossl_ffc_named_group_set(&dh->params, group);
		dh->params.nid = ossl_ffc_named_group_get_uid(group);
		dh->dirty_cnt++;
	}

	*ffc = ossl_dh_get0_params(dh);
	if (*ffc == NULL) {
		fprintf(stderr, "failed to gen ffc params\n");
		ossl_dh_free_ex(dh);
		return NULL;
	}

	dh->meth = DH_get_default_method();

	return dh;
}

static DH *uadk_prov_dh_gen_params_ex(PROV_DH_KEYMGMT_CTX *gctx, FFC_PARAMS **ffc)
{
	DH *dh = NULL;

	/* Use existing params */
	dh = ossl_dh_new_ex(gctx->libctx);
	if (dh == NULL) {
		fprintf(stderr, "failed to new dh by nid\n");
		return NULL;
	}

	*ffc = ossl_dh_get0_params(dh);
	if (*ffc == NULL) {
		fprintf(stderr, "failed to get ffc params\n");
		goto free_dh;
	}

	/* Copy the template value if one was passed */
	if (gctx->ffc_params != NULL && ossl_ffc_params_copy(*ffc, gctx->ffc_params) == 0) {
		fprintf(stderr, "failed to copy params\n");
		goto free_dh;
	}

	if (ossl_ffc_params_set_seed(*ffc, gctx->seed, gctx->seedlen) == 0) {
		fprintf(stderr, "failed to set seed\n");
		goto free_dh;
	}

	if (gctx->gindex != -1) {
		ossl_ffc_params_set_gindex(*ffc, gctx->gindex);
		if (gctx->pcounter != -1)
			ossl_ffc_params_set_pcounter(*ffc, gctx->pcounter);
	} else if (gctx->hindex != 0) {
		ossl_ffc_params_set_h(*ffc, gctx->hindex);
	}

	if (gctx->mdname) {
		if (ossl_ffc_set_digest(*ffc, gctx->mdname, gctx->mdprops) == 0) {
			fprintf(stderr, "failed to set digest\n");
			goto free_dh;
		}
	}

	return dh;

free_dh:
	ossl_dh_free_ex(dh);

	return NULL;
}

static int uadk_prov_dh_gen_params_cb(PROV_DH_KEYMGMT_CTX *gctx, DH *dh,
				      OSSL_CALLBACK *cb, void *cb_params, BN_GENCB *gencb)
{
	int ret;

	if (cb == NULL || cb_params == NULL) {
		fprintf(stderr, "invalid: cb function or param is NULL\n");
		return UADK_P_FAIL;
	}

	gctx->cb = cb;
	gctx->cbarg = cb_params;
	/* gencb can be NULL */
	gencb = BN_GENCB_new();
	if (gencb != NULL)
		BN_GENCB_set(gencb, dh_gencb, gctx);

	if ((gctx->selection & OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS) != 0) {
		/*
		 * NOTE: The old safe prime generator code is not used in fips mode,
		 * (i.e internally it ignores the generator and chooses a named
		 * group based on pbits.
		 */
		if (gctx->gen_type == DH_PARAMGEN_TYPE_GENERATOR)
			ret = DH_generate_parameters_ex(dh, gctx->pbits,
							gctx->generator, gencb);
		else
			ret = ossl_dh_generate_ffc_parameters(dh, gctx->gen_type,
						gctx->pbits, gctx->qbits, gencb);
		if (ret <= 0) {
			fprintf(stderr, "failed to generate ffc parameters\n");
			goto free_cb;
		}
	}

	return UADK_P_SUCCESS;

free_cb:
	if (gencb)
		BN_GENCB_free(gencb);

	return UADK_P_FAIL;
}

static void uadk_prov_dh_free_params_cb(BN_GENCB *gencb)
{
	if (gencb)
		BN_GENCB_free(gencb);
}

static DH *uadk_prov_dh_gen_params(PROV_DH_KEYMGMT_CTX *gctx, FFC_PARAMS **ffc,
				   OSSL_CALLBACK *cb, void *cb_params, BN_GENCB *gencb)
{
	DH *dh = NULL;
	int ret;

	/* For parameter generation - If there is a group name just create it */
	if (gctx->gen_type == DH_PARAMGEN_TYPE_GROUP && gctx->ffc_params == NULL) {
		dh = uadk_prov_dh_gen_params_with_group(gctx, ffc);
		if (dh == NULL || *ffc == NULL)
			return NULL;
	} else {
		dh = uadk_prov_dh_gen_params_ex(gctx, ffc);
		if (dh == NULL || *ffc == NULL)
			return NULL;

		ret = uadk_prov_dh_gen_params_cb(gctx, dh, cb, cb_params, gencb);
		if (ret == UADK_P_FAIL) {
			ossl_dh_free_ex(dh);
			return NULL;
		}
	}

	return dh;
}

static void uadk_prov_dh_free_params(DH *dh, BN_GENCB *gencb)
{
	/*
	 * Release DH object that allocated by uadk_prov_dh_gen_params_ex() or
	 * uadk_prov_dh_gen_params_with_group().
	 */
	ossl_dh_free_ex(dh);
	uadk_prov_dh_free_params_cb(gencb);
}

static void *uadk_dh_sw_gen(void *genctx, OSSL_CALLBACK *cb, void *cb_params)
{
	if (!enable_sw_offload || !get_default_dh_keymgmt().gen)
		return NULL;

	fprintf(stderr, "switch to openssl software calculation in dh generation.\n");
	return get_default_dh_keymgmt().gen(genctx, cb, cb_params);
}

static void *uadk_keymgmt_dh_gen(void *genctx, OSSL_CALLBACK *cb, void *cb_params)
{
	PROV_DH_KEYMGMT_CTX *gctx = (PROV_DH_KEYMGMT_CTX *)genctx;
	BN_GENCB *gencb = NULL;
	FFC_PARAMS *ffc = NULL;
	DH *dh = NULL;
	int ret;

	if (gctx == NULL) {
		fprintf(stderr, "invalid: keygen ctx is NULL\n");
		return NULL;
	}

	/*
	 * If a group name is selected then the type is group regardless of what
	 * the user selected. This overrides rather than errors for backwards
	 * compatibility.
	 */
	if (gctx->group_nid != NID_undef)
		gctx->gen_type = DH_PARAMGEN_TYPE_GROUP;

	dh = uadk_prov_dh_gen_params(gctx, &ffc, cb, cb_params, gencb);
	if (dh == NULL || ffc == NULL) {
		ret = UADK_DO_SOFT;
		goto free_gen_params;
	}
	/* DH key generation */
	if ((gctx->selection & OSSL_KEYMGMT_SELECT_KEYPAIR) != 0) {
		if (ffc->p == NULL || ffc->g == NULL) {
			fprintf(stderr, "invalid: ffc->p or ffc->g is NULL\n");
			goto free_gen_params;
		}

		if (gctx->priv_len > 0)
			(void)DH_set_length(dh, (long)gctx->priv_len);

		ossl_ffc_params_enable_flags(ffc, FFC_PARAM_FLAG_VALIDATE_LEGACY,
					gctx->gen_type == DH_PARAMGEN_TYPE_FIPS_186_2);

		ret = uadk_prov_dh_generate_key(dh);
		if (ret != UADK_P_SUCCESS) {
			fprintf(stderr, "failed to do dh generation key\n");
			goto free_gen_params;
		}
	}

	uadk_DH_clear_flags(dh, DH_FLAG_TYPE_MASK);
	uadk_DH_set_flags(dh, gctx->dh_type);
	uadk_prov_dh_free_params_cb(gencb);

	return dh;

free_gen_params:
	uadk_prov_dh_free_params(dh, gencb);

	if (ret == UADK_DO_SOFT)
		return uadk_dh_sw_gen(genctx, cb, cb_params);
	return NULL;
}

static int uadk_DH_size(const DH *dh)
{
	/* DH object has been checked when the function is called */
	if (dh->params.p != NULL)
		return BN_num_bytes(dh->params.p);

	/* size zero */
	return 0;
}

static void uadk_DH_get0_key(const DH *dh, const BIGNUM **pubkey,
			     const BIGNUM **prikey)
{
	/* DH object has been checked when the function is called */
	if (pubkey != NULL)
		*pubkey = dh->pub_key;

	if (prikey != NULL)
		*prikey = dh->priv_key;
}

static void *uadk_keyexch_dh_newctx(void *provctx)
{
	PROV_DH_KEYEXCH_CTX *pdhctx;

	pdhctx = OPENSSL_zalloc(sizeof(PROV_DH_KEYEXCH_CTX));
	if (pdhctx == NULL) {
		fprintf(stderr, "failed to alloc pdhctx\n");
		return NULL;
	}

	/* The libctx maybe NULL, if libctx is NULL, will use default ctx. */
	pdhctx->libctx = prov_libctx_of(provctx);
	pdhctx->kdf_type = PROV_DH_KDF_NONE;

	return pdhctx;
}

static void uadk_keyexch_dh_freectx(void *dhctx)
{
	PROV_DH_KEYEXCH_CTX *pdhctx = (PROV_DH_KEYEXCH_CTX *)dhctx;

	if (pdhctx == NULL)
		return;

	if (pdhctx->kdf_cekalg) {
		OPENSSL_free(pdhctx->kdf_cekalg);
		pdhctx->kdf_cekalg = NULL;
	}

	if (pdhctx->dh) {
		DH_free(pdhctx->dh);
		pdhctx->dh = NULL;
	}

	if (pdhctx->dhpeer) {
		DH_free(pdhctx->dhpeer);
		pdhctx->dhpeer = NULL;
	}

	if (pdhctx->kdf_md) {
		EVP_MD_free(pdhctx->kdf_md);
		pdhctx->kdf_md = NULL;
	}

	if (pdhctx->kdf_ukm) {
		OPENSSL_clear_free(pdhctx->kdf_ukm, pdhctx->kdf_ukmlen);
		pdhctx->kdf_ukm = NULL;
	}

	if (pdhctx->kdf_cekalg) {
		OPENSSL_free(pdhctx->kdf_cekalg);
		pdhctx->kdf_cekalg = NULL;
	}

	OPENSSL_free(pdhctx);
}

static int uadk_keyexch_dh_init(void *dhctx, void *dh, const OSSL_PARAM params[])
{
	PROV_DH_KEYEXCH_CTX *pdhctx = (PROV_DH_KEYEXCH_CTX *)dhctx;

	if (pdhctx == NULL) {
		fprintf(stderr, "invalid: dhctx is NULL\n");
		return UADK_P_FAIL;
	}

	if (dh == NULL || !DH_up_ref(dh)) {
		fprintf(stderr, "invalid: dh is NULL\n");
		return UADK_P_FAIL;
	}

	pthread_mutex_lock(&dh_mutex);
	if (pdhctx->dh) {
		DH_free(pdhctx->dh);
		pdhctx->dh = NULL;
	}

	pdhctx->dh = dh;
	pdhctx->kdf_type = PROV_DH_KDF_NONE;
	pthread_mutex_unlock(&dh_mutex);

	return uadk_keyexch_dh_set_ctx_params(pdhctx, params);
}

/* The 2 parties must share the same domain parameters */
static int uadk_keyexch_dh_match_params(DH *priv, DH *peer)
{
	FFC_PARAMS *dhparams_priv = ossl_dh_get0_params(priv);
	FFC_PARAMS *dhparams_peer = ossl_dh_get0_params(peer);
	int ret;

	if (dhparams_priv == NULL || dhparams_peer == NULL) {
		fprintf(stderr, "failed to get dh params\n");
		return UADK_P_FAIL;
	}

	ret = ossl_ffc_params_cmp(dhparams_priv, dhparams_peer, IGNORE_Q);
	if (ret == UADK_P_FAIL)
		fprintf(stderr, "invalid: domain parameters of both parties do not match\n");

	return ret;
}

static int uadk_keyexch_dh_set_peer(void *dhctx, void *dh)
{
	PROV_DH_KEYEXCH_CTX *pdhctx = (PROV_DH_KEYEXCH_CTX *)dhctx;

	if (pdhctx == NULL || dh == NULL) {
		fprintf(stderr, "invalid: dh ctx or object is NULL\n");
		return UADK_P_FAIL;
	}

	if (uadk_keyexch_dh_match_params(dh, pdhctx->dh) == UADK_P_FAIL ||
		DH_up_ref(dh) == UADK_P_FAIL) {
		fprintf(stderr, "failed to match dh params\n");
		return UADK_P_FAIL;
	}

	pthread_mutex_lock(&dh_mutex);
	if (pdhctx->dhpeer)
		DH_free(pdhctx->dhpeer);
	pdhctx->dhpeer = dh;
	pthread_mutex_unlock(&dh_mutex);

	return UADK_P_SUCCESS;
}

static int uadk_prov_dh_fill_compkey_req(const BIGNUM *g, const BIGNUM *p,
					 const BIGNUM *prikey, const BIGNUM *pubkey,
					 struct uadk_dh_sess *dh_sess)
{
	unsigned char *x_bin, *p_bin, *g_bin, *out_pri;
	__u16 key_size = dh_sess->key_size;

	g_bin = OPENSSL_zalloc(key_size);
	if (g_bin == NULL) {
		fprintf(stderr, "failed to alloc g\n");
		return UADK_P_FAIL;
	}

	/* x is private key, x and p will be treated together in uadk */
	x_bin = OPENSSL_zalloc(key_size * DH_PARAMS_CNT);
	if (x_bin == NULL) {
		fprintf(stderr, "failed to alloc x_bin\n");
		goto free_g;
	}

	p_bin = x_bin + key_size;
	out_pri = p_bin + key_size;

	/* Construct data block of g */
	if (dh_set_g(g, key_size, g_bin, dh_sess) == UADK_P_FAIL)
		goto free_priv;

	dh_sess->req.x_p = x_bin;
	dh_sess->req.xbytes = BN_bn2bin(prikey, x_bin);
	dh_sess->req.pbytes = BN_bn2bin(p, p_bin);

	dh_sess->req.pv = g_bin;
	dh_sess->req.pvbytes = BN_bn2bin(pubkey, g_bin);
	dh_sess->req.pri = out_pri;
	dh_sess->req.pri_bytes = key_size;
	dh_sess->req.op_type = WD_DH_PHASE2;

	return UADK_P_SUCCESS;

free_priv:
	OPENSSL_free(x_bin);
free_g:
	OPENSSL_free(g_bin);

	return UADK_P_FAIL;
}

static void uadk_prov_dh_free_compkey_req(struct uadk_dh_sess *dh_sess)
{
	if (dh_sess == NULL)
		return;

	/* Free x_bin, p_bin and pri_bin */
	if (dh_sess->req.x_p) {
		OPENSSL_free(dh_sess->req.x_p);
		dh_sess->req.x_p = NULL;
	}

	/* Free pv */
	if (dh_sess->req.pv) {
		OPENSSL_free(dh_sess->req.pv);
		dh_sess->req.pv = NULL;
	}
}

static int uadk_dh_compute_key(unsigned char *key, const BIGNUM *pubkey, DH *dh)
{
	struct uadk_dh_sess *dh_sess = NULL;
	BIGNUM *prikey = NULL;
	const BIGNUM *p = NULL;
	const BIGNUM *g = NULL;
	int ret;

	if (!dh || !key || !pubkey || !uadk_DH_get0_priv_key(dh)) {
		fprintf(stderr, "failed to check key params\n");
		return UADK_P_FAIL;
	}

	uadk_DH_get0_pqg(dh, &p, NULL, &g);
	if (!p || !g) {
		fprintf(stderr, "failed to get p/q/g param\n");
		return UADK_P_FAIL;
	}

	ret = uadk_prov_dh_init();
	if (ret) {
		fprintf(stderr, "failed to init\n");
		return UADK_DO_SOFT;
	}

	ret = uadk_prov_dh_prepare_data(g, dh, &dh_sess, &prikey);
	if (ret != UADK_P_SUCCESS) {
		fprintf(stderr, "failed to prepare dh data\n");
		return ret;
	}

	ret = uadk_prov_dh_fill_compkey_req(g, p, prikey, pubkey, dh_sess);
	if (ret == UADK_P_FAIL) {
		fprintf(stderr, "failed to fill req\n");
		goto free_data;
	}

	ret = uadk_prov_dh_do_crypto(dh_sess);
	if (ret != UADK_P_SUCCESS) {
		fprintf(stderr, "failed to generate DH shared key\n");
		ret = UADK_DO_SOFT;
		goto free_req;
	}

	memcpy(key, dh_sess->req.pri, dh_sess->req.pri_bytes);
	ret = dh_sess->req.pri_bytes;
	uadk_prov_dh_free_compkey_req(dh_sess);
	/* key will be used by user, do not free it here */
	uadk_prov_dh_free_session(dh_sess);

	return ret;

free_req:
	uadk_prov_dh_free_compkey_req(dh_sess);
free_data:
	uadk_prov_dh_free_prepare_data(dh_sess, prikey);

	return ret;
}

static int uadk_dh_compute_key_padded(unsigned char *key, const BIGNUM *pub_key, DH *dh)
{
	size_t dhsize;
	int rv, pad;

	/* rv is constant unless compute_key is external */
	rv = uadk_dh_compute_key(key, pub_key, dh);
	if (rv <= 0)
		return rv;

	dhsize = BN_num_bytes(dh->params.p);
	pad = dhsize - rv;
	/* pad is constant (zero) unless compute_key is external */
	if (pad > 0) {
		memmove(key + pad, key, rv);
		memset(key, 0, pad);
	}

	if (pad < 0) {
		fprintf(stderr, "invalid: recv key size(%d) > dhsize(%zu)", rv, dhsize);
		return UADK_P_FAIL;
	}

	return rv + pad;
}

static int uadk_prov_dh_plain_derive(PROV_DH_KEYEXCH_CTX *pdhctx, unsigned char *secret,
				size_t *secretlen, size_t outlen, unsigned int pad)
{
	const BIGNUM *pubkey = NULL;
	size_t dhsize;
	int ret;

	/* pdhctx has been checked when the function is called */
	if (pdhctx->dh == NULL) {
		fprintf(stderr, "invalid: dh is NULL\n");
		return UADK_P_FAIL;
	}

	dhsize = (size_t)uadk_DH_size(pdhctx->dh);
	if (dhsize == 0) {
		fprintf(stderr, "invalid: dhszie is zero\n");
		return UADK_P_FAIL;
	}

	if (secret == NULL) {
		*secretlen = dhsize;
		return UADK_P_SUCCESS;
	}

	if (outlen < dhsize) {
		fprintf(stderr, "invalid: outlen(%zu) < dhsize(%zu)\n", outlen, dhsize);
		return UADK_P_FAIL;
	}

	if (pdhctx->dhpeer == NULL) {
		fprintf(stderr, "invalid: dhpeer is NULL\n");
		return UADK_P_FAIL;
	}

	uadk_DH_get0_key(pdhctx->dhpeer, &pubkey, NULL);

	if (pad)
		ret = uadk_dh_compute_key_padded(secret, pubkey, pdhctx->dh);
	else
		ret = uadk_dh_compute_key(secret, pubkey, pdhctx->dh);
	if (ret <= 0) {
		fprintf(stderr, "failed to do dh compute, pad(%u)\n", pad);
		return ret;
	}

	*secretlen = ret;

	return UADK_P_SUCCESS;
}

/* Key derivation function from X9.63/SECG */
static int ossl_dh_kdf_X9_42_asn1(unsigned char *out, PROV_DH_KEYEXCH_CTX *pdhctx,
				  const unsigned char *z, size_t z_len,
				  const char *propq)
{
	OSSL_LIB_CTX *libctx = pdhctx->libctx;
	const char *cek_alg = pdhctx->kdf_cekalg;
	const unsigned char *ukm = pdhctx->kdf_ukm;
	OSSL_PARAM params[KDF_PARAM_NUM] = {0};
	size_t outlen = pdhctx->kdf_outlen;
	size_t ukmlen = pdhctx->kdf_ukmlen;
	const EVP_MD *md = pdhctx->kdf_md;
	OSSL_PARAM *p = params;
	EVP_KDF_CTX *kctx = NULL;
	EVP_KDF *kdf = NULL;
	const char *mdname;
	int ret = 0;

	kdf = EVP_KDF_fetch(libctx, OSSL_KDF_NAME_X942KDF_ASN1, propq);
	if (kdf == NULL)
		return 0;

	kctx = EVP_KDF_CTX_new(kdf);
	if (kctx == NULL)
		goto end;

	mdname = EVP_MD_get0_name(md);
	*p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
						(char *)mdname, 0);
	*p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY,
						(unsigned char *)z, z_len);
	if (ukm != NULL)
		*p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_UKM,
							(unsigned char *)ukm, ukmlen);

	*p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_CEK_ALG,
						(char *)cek_alg, 0);
	*p = OSSL_PARAM_construct_end();
	ret = EVP_KDF_derive(kctx, out, outlen, params) > 0;

end:
	EVP_KDF_CTX_free(kctx);
	EVP_KDF_free(kdf);

	return ret;
}

static int uadk_prov_dh_X9_42_kdf_derive(PROV_DH_KEYEXCH_CTX *pdhctx, unsigned char *secret,
					size_t *secretlen, size_t outlen)
{
	unsigned char *stmp = NULL;
	size_t stmplen;
	int ret = 0;

	if (secret == NULL) {
		*secretlen = pdhctx->kdf_outlen;
		return UADK_P_SUCCESS;
	}

	if (outlen < pdhctx->kdf_outlen) {
		fprintf(stderr, "invalid: outlen(%zu) < kdf_outlen(%zu)\n",
			outlen, pdhctx->kdf_outlen);
		return UADK_P_FAIL;
	}

	if (!uadk_prov_dh_plain_derive(pdhctx, NULL, &stmplen, 0, 1))
		return UADK_P_FAIL;

	stmp = OPENSSL_secure_malloc(stmplen);
	if (stmp == NULL) {
		fprintf(stderr, "failed to do OPENSSL_secure_malloc\n");
		return UADK_P_FAIL;
	}

	ret = uadk_prov_dh_plain_derive(pdhctx, stmp, &stmplen, stmplen, USE_PAD);
	if (ret != UADK_P_SUCCESS)
		goto end;

	/* Do KDF stuff */
	if (pdhctx->kdf_type == PROV_DH_KDF_X9_42_ASN1) {
		if (ossl_dh_kdf_X9_42_asn1(secret, pdhctx, stmp, stmplen, NULL) == UADK_P_FAIL) {
			ret = UADK_P_FAIL;
			fprintf(stderr, "failed to do ossl_dh_kdf_X9_42_asn1\n");
			goto end;
		}
	}

	*secretlen = pdhctx->kdf_outlen;
	ret = UADK_P_SUCCESS;

end:
	OPENSSL_secure_clear_free(stmp, stmplen);

	return ret;
}

static int uadk_dh_sw_derive(void *dhctx, unsigned char *secret,
			  size_t *psecretlen, size_t outlen)
{
	if (!enable_sw_offload || !get_default_dh_keyexch().derive)
		return UADK_P_FAIL;

	fprintf(stderr, "switch to openssl software calculation in dh derivation.\n");
	return get_default_dh_keyexch().derive(dhctx, secret, psecretlen, outlen);
}

static int uadk_keyexch_dh_derive(void *dhctx, unsigned char *secret,
				  size_t *psecretlen, size_t outlen)
{
	PROV_DH_KEYEXCH_CTX *pdhctx = (PROV_DH_KEYEXCH_CTX *)dhctx;
	int ret = UADK_P_FAIL;

	if (pdhctx == NULL) {
		fprintf(stderr, "invalid: pdhctx is NULL\n");
		return UADK_P_FAIL;
	}

	switch (pdhctx->kdf_type) {
	case PROV_DH_KDF_NONE:
		ret = uadk_prov_dh_plain_derive(pdhctx, secret, psecretlen, outlen, pdhctx->pad);
		break;
	case PROV_DH_KDF_X9_42_ASN1:
		ret = uadk_prov_dh_X9_42_kdf_derive(pdhctx, secret, psecretlen, outlen);
		break;
	default:
		fprintf(stderr, "invalid: unsupport kdf type\n");
		ret = UADK_DO_SOFT;
		break;
	}

	if (ret == UADK_P_SUCCESS)
		return UADK_P_SUCCESS;
	if (ret == UADK_DO_SOFT)
		return uadk_dh_sw_derive(dhctx, secret, psecretlen, outlen);
	return UADK_P_FAIL;
}

static void *uadk_keyexch_dh_dupctx(void *dhctx)
{
	PROV_DH_KEYEXCH_CTX *srcctx = (PROV_DH_KEYEXCH_CTX *)dhctx;
	PROV_DH_KEYEXCH_CTX *dstctx;

	if (srcctx == NULL) {
		fprintf(stderr, "invalid: src ctx is NULL\n");
		return NULL;
	}

	dstctx = OPENSSL_zalloc(sizeof(*dstctx));
	if (dstctx == NULL) {
		fprintf(stderr, "failed to alloc dst ctx\n");
		return NULL;
	}

	memcpy(dstctx, srcctx, sizeof(PROV_DH_KEYEXCH_CTX));
	dstctx->dh = NULL;
	dstctx->dhpeer = NULL;
	dstctx->kdf_md = NULL;
	dstctx->kdf_ukm = NULL;
	dstctx->kdf_cekalg = NULL;

	if (srcctx->dh && !DH_up_ref(srcctx->dh))
		goto err;
	else
		dstctx->dh = srcctx->dh;

	if (srcctx->dhpeer && !DH_up_ref(srcctx->dhpeer))
		goto err;
	else
		dstctx->dhpeer = srcctx->dhpeer;

	if (srcctx->kdf_md && !EVP_MD_up_ref(srcctx->kdf_md))
		goto err;
	else
		dstctx->kdf_md = srcctx->kdf_md;

	/* Duplicate UKM data if present */
	if (srcctx->kdf_ukm && srcctx->kdf_ukmlen > 0) {
		dstctx->kdf_ukm = OPENSSL_memdup(srcctx->kdf_ukm,
						 srcctx->kdf_ukmlen);
		if (dstctx->kdf_ukm == NULL)
			goto err;
	}

	if (srcctx->kdf_cekalg != NULL) {
		dstctx->kdf_cekalg = OPENSSL_strdup(srcctx->kdf_cekalg);
		if (dstctx->kdf_cekalg == NULL)
			goto err;
	}

	return dstctx;

err:
	uadk_keyexch_dh_freectx(dstctx);

	return NULL;
}

static int uadk_prov_dh_locate_kdf_type(PROV_DH_KEYEXCH_CTX *pdhctx, const OSSL_PARAM params[])
{
	char name[DH_MAX_PARAM_LEN + 1] = {'\0'};
	const OSSL_PARAM *p;
	char *str = NULL;

	p = OSSL_PARAM_locate_const(params, OSSL_EXCHANGE_PARAM_KDF_TYPE);
	if (p != NULL) {
		str = name;
		if (!OSSL_PARAM_get_utf8_string(p, &str, sizeof(name)))
			return UADK_P_FAIL;

		if (name[0] == '\0')
			pdhctx->kdf_type = PROV_DH_KDF_NONE;
		else if (strcmp(name, OSSL_KDF_NAME_X942KDF_ASN1) == 0)
			pdhctx->kdf_type = PROV_DH_KDF_X9_42_ASN1;
		else
			return UADK_P_FAIL;
	}

	return UADK_P_SUCCESS;
}

static int uadk_prov_dh_locate_kdf_digest(PROV_DH_KEYEXCH_CTX *pdhctx,
					  const OSSL_PARAM params[])
{
	char mdprops[DH_MAX_PARAM_LEN + 1] = {'\0'};
	char name[DH_MAX_PARAM_LEN + 1] = {'\0'};
	const OSSL_PARAM *p;
	char *str = NULL;

	p = OSSL_PARAM_locate_const(params, OSSL_EXCHANGE_PARAM_KDF_DIGEST);
	if (p != NULL) {
		str = name;
		if (!OSSL_PARAM_get_utf8_string(p, &str, sizeof(name)))
			return UADK_P_FAIL;

		str = mdprops;
		p = OSSL_PARAM_locate_const(params,
					    OSSL_EXCHANGE_PARAM_KDF_DIGEST_PROPS);
		if (p != NULL)
			if (!OSSL_PARAM_get_utf8_string(p, &str, sizeof(mdprops)))
				return UADK_P_FAIL;

		if (pdhctx->kdf_md)
			EVP_MD_free(pdhctx->kdf_md);

		pdhctx->kdf_md = EVP_MD_fetch(pdhctx->libctx, name, mdprops);
		if (pdhctx->kdf_md == NULL)
			return UADK_P_FAIL;
	}

	return UADK_P_SUCCESS;
}

static int uadk_prov_dh_locate_kdf_outlen(PROV_DH_KEYEXCH_CTX *pdhctx,
					  const OSSL_PARAM params[])
{
	const OSSL_PARAM *p;
	size_t outlen = 0;

	p = OSSL_PARAM_locate_const(params, OSSL_EXCHANGE_PARAM_KDF_OUTLEN);
	if (p != NULL) {
		if (!OSSL_PARAM_get_size_t(p, &outlen))
			return UADK_P_FAIL;
		pdhctx->kdf_outlen = outlen;
	}

	return UADK_P_SUCCESS;
}

static int uadk_prov_dh_locate_kdf_ukm(PROV_DH_KEYEXCH_CTX *pdhctx, const OSSL_PARAM params[])
{
	const OSSL_PARAM *p;
	void *tmp_ukm = NULL;
	size_t tmp_ukmlen;

	p = OSSL_PARAM_locate_const(params, OSSL_EXCHANGE_PARAM_KDF_UKM);
	if (p != NULL) {
		if (pdhctx->kdf_ukm)
			OPENSSL_free(pdhctx->kdf_ukm);
		pdhctx->kdf_ukm = NULL;
		pdhctx->kdf_ukmlen = 0;

		/* ukm is an optional field so it can be NULL */
		if (p->data != NULL && p->data_size != 0) {
			if (!OSSL_PARAM_get_octet_string(p, &tmp_ukm, 0, &tmp_ukmlen))
				return UADK_P_FAIL;
			pdhctx->kdf_ukm = tmp_ukm;
			pdhctx->kdf_ukmlen = tmp_ukmlen;
		}
	}

	return UADK_P_SUCCESS;
}

static int uadk_prov_dh_locate_kdf_pad(PROV_DH_KEYEXCH_CTX *pdhctx, const OSSL_PARAM params[])
{
	const OSSL_PARAM *p;
	unsigned int pad = 0;

	p = OSSL_PARAM_locate_const(params, OSSL_EXCHANGE_PARAM_PAD);
	if (p != NULL) {
		if (!OSSL_PARAM_get_uint(p, &pad))
			return UADK_P_FAIL;
		pdhctx->pad = pad ? 1 : 0;
	}

	return UADK_P_SUCCESS;
}

static int uadk_keyexch_dh_set_ctx_params(void *dhctx, const OSSL_PARAM params[])
{
	PROV_DH_KEYEXCH_CTX *pdhctx = (PROV_DH_KEYEXCH_CTX *)dhctx;
	int ret = UADK_P_FAIL;

	if (pdhctx == NULL) {
		fprintf(stderr, "invalid: dh ctx is NULL\n");
		return ret;
	}

	/* If params is NULL, no need to set */
	if (params == NULL)
		return UADK_P_SUCCESS;

	pthread_mutex_lock(&dh_mutex);
	ret = uadk_prov_dh_locate_kdf_type(pdhctx, params);
	if (ret == UADK_P_FAIL) {
		fprintf(stderr, "failed to locate kdf type\n");
		goto end;
	}

	ret = uadk_prov_dh_locate_kdf_digest(pdhctx, params);
	if (ret == UADK_P_FAIL) {
		fprintf(stderr, "failed to locate kdf digest\n");
		goto end;
	}

	ret = uadk_prov_dh_locate_kdf_outlen(pdhctx, params);
	if (ret == UADK_P_FAIL) {
		fprintf(stderr, "failed to locate kdf outlen\n");
		goto end;
	}

	ret = uadk_prov_dh_locate_kdf_ukm(pdhctx, params);
	if (ret == UADK_P_FAIL) {
		fprintf(stderr, "failed to locate kdf ukm\n");
		goto end;
	}

	ret = uadk_prov_dh_locate_kdf_pad(pdhctx, params);
	if (ret == UADK_P_FAIL)
		fprintf(stderr, "failed to locate kdf pad\n");

end:
	pthread_mutex_unlock(&dh_mutex);
	return ret;
}

static const OSSL_PARAM known_settable_ctx_params[] = {
	OSSL_PARAM_int(OSSL_EXCHANGE_PARAM_PAD, NULL),
	OSSL_PARAM_utf8_string(OSSL_EXCHANGE_PARAM_KDF_TYPE, NULL, 0),
	OSSL_PARAM_utf8_string(OSSL_EXCHANGE_PARAM_KDF_DIGEST, NULL, 0),
	OSSL_PARAM_utf8_string(OSSL_EXCHANGE_PARAM_KDF_DIGEST_PROPS, NULL, 0),
	OSSL_PARAM_size_t(OSSL_EXCHANGE_PARAM_KDF_OUTLEN, NULL),
	OSSL_PARAM_octet_string(OSSL_EXCHANGE_PARAM_KDF_UKM, NULL, 0),
	OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_CEK_ALG, NULL, 0),
	OSSL_PARAM_END
};

static const OSSL_PARAM *uadk_keyexch_dh_settable_ctx_params(ossl_unused void *dhctx,
						ossl_unused void *provctx)
{
	return known_settable_ctx_params;
}

static const OSSL_PARAM known_gettable_ctx_params[] = {
	OSSL_PARAM_utf8_string(OSSL_EXCHANGE_PARAM_KDF_TYPE, NULL, 0),
	OSSL_PARAM_utf8_string(OSSL_EXCHANGE_PARAM_KDF_DIGEST, NULL, 0),
	OSSL_PARAM_size_t(OSSL_EXCHANGE_PARAM_KDF_OUTLEN, NULL),
	OSSL_PARAM_DEFN(OSSL_EXCHANGE_PARAM_KDF_UKM, OSSL_PARAM_OCTET_PTR, NULL, 0),
	OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_CEK_ALG, NULL, 0),
	OSSL_PARAM_END
};

static const OSSL_PARAM *uadk_keyexch_dh_gettable_ctx_params(ossl_unused void *dhctx,
						ossl_unused void *provctx)
{
	return known_gettable_ctx_params;
}

static int uadk_keyexch_dh_get_ctx_params(void *dhctx, OSSL_PARAM params[])
{
	PROV_DH_KEYEXCH_CTX *pdhctx = (PROV_DH_KEYEXCH_CTX *)dhctx;
	const char *kdf_type = NULL;
	OSSL_PARAM *p;

	if (pdhctx == NULL) {
		fprintf(stderr, "invalid: dh ctx is NULL\n");
		return UADK_P_FAIL;
	}

	p = OSSL_PARAM_locate(params, OSSL_EXCHANGE_PARAM_KDF_TYPE);
	if (p != NULL) {
		switch (pdhctx->kdf_type) {
		case PROV_DH_KDF_NONE:
			kdf_type = "";
			break;
		case PROV_DH_KDF_X9_42_ASN1:
			kdf_type = OSSL_KDF_NAME_X942KDF_ASN1;
			break;
		default:
			fprintf(stderr, "invalid kdf_type\n");
			return UADK_P_FAIL;
		}

		if (!OSSL_PARAM_set_utf8_string(p, kdf_type)) {
			fprintf(stderr, "failed to set utf8 string for kdf_type\n");
			return UADK_P_FAIL;
		}
	}

	p = OSSL_PARAM_locate(params, OSSL_EXCHANGE_PARAM_KDF_DIGEST);
	if (p != NULL && !OSSL_PARAM_set_utf8_string(p, pdhctx->kdf_md == NULL
				? "" : EVP_MD_get0_name(pdhctx->kdf_md))) {
		fprintf(stderr, "failed to set kdf_md\n");
		return UADK_P_FAIL;
	}

	p = OSSL_PARAM_locate(params, OSSL_EXCHANGE_PARAM_KDF_OUTLEN);
	if (p != NULL && !OSSL_PARAM_set_size_t(p, pdhctx->kdf_outlen)) {
		fprintf(stderr, "failed to set kdf_outlen\n");
		return UADK_P_FAIL;
	}

	p = OSSL_PARAM_locate(params, OSSL_EXCHANGE_PARAM_KDF_UKM);
	if (p != NULL && !OSSL_PARAM_set_octet_ptr(p, pdhctx->kdf_ukm, pdhctx->kdf_ukmlen)) {
		fprintf(stderr, "failed to set kdf_ukm\n");
		return UADK_P_FAIL;
	}

	p = OSSL_PARAM_locate(params, OSSL_KDF_PARAM_CEK_ALG);
	if (p != NULL && !OSSL_PARAM_set_utf8_string(p, pdhctx->kdf_cekalg == NULL
				? "" : pdhctx->kdf_cekalg)) {
		fprintf(stderr, "failed to set kdf_cekalg\n");
		return UADK_P_FAIL;
	}

	return UADK_P_SUCCESS;
}
